classdef AlignSummary
% this class stores aggregate statistics regarding event timing and is
% typically generated and stored within an AlignInfo instance. Its purpose
% is to store this information encapsulated from AlignInfo data.
% AlignSummary objects are generated by a pair of AlignDescriptor and
% ConditionDescriptor objects, because they generate a separate set of
% aggregate event occurrence statistics for each condition

    properties(SetAccess=protected)
        % AlignDescriptor object from which this was generated
        alignDescriptor
        
        % ConditionDescriptor object from which this was generated
        conditionDescriptor
    end
    
    properties
        timeUnitName = '';
    end
    
    properties(Dependent, SetAccess=protected)
        nConditions
        
        nMarks
        nOccurrencesByMark
        
        nIntervals
        nOccurrencesByInterval
    end
    
    properties(SetAccess=protected)
        nTrials
        
        startMin
        startMax
        startMean
        
        stopMin
        stopMax
        stopMean
       
        % nMark x 1 cell array with nOccurrences x 1 vectors
        markMax
        markMin
        markMean
        
        % nInterval x 1 cell array with nOccurrences x 1 vectors
        intervalStartMax
        intervalStartMin
        intervalStartMean
        
        % nInterval x 1 cell array of nOccurrences x 1 vectors
        intervalStopMax
        intervalStopMin
        intervalStopMean
        
        % nConditions x 1 numeric array indicating how many trials
        % contribute to the statistics above (useful when aggregating)
        nTrialsByCondition
        
        % all times are relative to zero 
        % nConditions x 1 vector of earliest start times by condition
        startMinByCondition
        
        % nConditions x 1 vector of latest start times by condition
        startMaxByCondition
        
        % nConditions x 1 vector of mean start times by condition
        startMeanByCondition
        
        % nConditions x 1 vector of earliest stop times by condition
        stopMinByCondition
        
        % nConditions x 1 vector of earliest stop times by condition
        stopMaxByCondition
        
        % nConditions x 1 vector of mean stop times by condition
        stopMeanByCondition
        
        % nMarks x 1 cell with nConditions x nOccurrences matrices of
        % latest occurrence time(s) of that mark event (relative to the zero event)
        markMaxByCondition
        
        % nMarks x 1 cell with nConditions x nOccurrences matrices of
        % earliest occurrence time(s) of that mark event (relative to the zero event)
        markMinByCondition
        
        % nMarks x 1 cell with nConditions x nOccurrences matrices of
        % mean occurrence time(s) of that mark event (relative to the zero event)
        markMeanByCondition
        
        % nIntervals x 1 cell with nConditions x nOccurrences matrices of
        % latest occurrence time of the start of each occurrence of that interval 
        % (relative to the zero event)
        intervalStartMaxByCondition
       
        intervalStartMinByCondition
        
        intervalStartMeanByCondition
        
        intervalStopMaxByCondition
        
        intervalStopMinByCondition
        
        intervalStopMeanByCondition
    
        % these are build by initialize() 
        labelInfo
        intervalInfo
    end
    
    methods
        function as = AlignSummary()
        end
    end
    
    methods % Simple dependent properties
        function n = get.nConditions(as)
            n = numel(as.nTrialsByCondition);
        end
        
        function n = get.nMarks(as)
            n = numel(as.markMax);
        end
        
        function nvec = get.nOccurrencesByMark(as)
            % markMean is nMark x 1 cell array with nOccurrences x 1 vectors
            nvec = cellfun(@numel, as.markMean);
        end
        
        function n = get.nIntervals(as)
            n = numel(as.intervalStartMax);
        end
        
        function nvec = get.nOccurrencesByInterval(as)
            % intervalStartMean is nMark x 1 cell array with nOccurrences x 1 vectors
            nvec = cellfun(@numel, as.intervalStartMean);
        end
    end
    
    methods(Static)
        % factory constructor method used by TDCA
        function as = buildFromConditionAlignInfo(conditionInfo, alignInfo)
            as = AlignSummary();
            as.alignDescriptor = AlignDescriptor.fromAlignDescriptor(alignInfo);
            
            % fix value lists to their current values before converting to
            % condition descriptor
            conditionInfo = conditionInfo.fixAllValueLists();
            as.conditionDescriptor = ConditionDescriptor.fromConditionDescriptor(conditionInfo);
            
            % request aligned, ungrouped data for start/stop/marks/intervals
            [startData, stopData] = alignInfo.getStartStopRelativeToZeroByTrial();
            markData = alignInfo.getAlignedMarkData();
            [intervalStartData, intervalStopData] = alignInfo.getAlignedIntervalData();
            
            % total number of valid trials contributing
            as.nTrials = nnz(alignInfo.valid);
            
             % compute summary statistics for all trials
            [as.startMin, as.startMax, as.startMean] = ...
                statsSingleEvent(startData);
            [as.stopMin, as.stopMax, as.stopMean] = ...
                statsSingleEvent(stopData);
            
            % group the data by condition into a flattened nConditions x 1
            % array
            as.nTrialsByCondition = cellfun(@numel, conditionInfo.listByCondition(:));
            [startGrouped, stopGrouped] = conditionInfo.groupElementsFlattened(startData, stopData);
 
            % compute summary statistics for each condition separately
            [as.startMinByCondition, as.startMaxByCondition, as.startMeanByCondition] = ...
                statsSingleEventByCondition(startGrouped);
            [as.stopMinByCondition, as.stopMaxByCondition, as.stopMeanByCondition] = ...
                statsSingleEventByCondition(stopGrouped);
            
            % compute summary statistics for EACH occurrence of EACH
            % mark and interval event.
            [as.markMin, as.markMax, as.markMean] = ...
                statsMultipleEvent(markData);
            [as.intervalStartMin, as.intervalStartMax, as.intervalStartMean] = ...
                statsMultipleEvent(intervalStartData);
            [as.intervalStopMin, as.intervalStopMax, as.intervalStopMean] = ...
                statsMultipleEvent(intervalStopData);
            
            % compute summary statistics for EACH occurrence of EACH
            % mark and interval event by condition
            [as.markMinByCondition, as.markMaxByCondition, as.markMeanByCondition] = ...
                statsMultipleEventByCondition(markData, conditionInfo);
            [as.intervalStartMinByCondition, as.intervalStartMaxByCondition, as.intervalStartMeanByCondition] = ...
                statsMultipleEventByCondition(intervalStartData, conditionInfo);
            [as.intervalStopMinByCondition, as.intervalStopMaxByCondition, as.intervalStopMeanByCondition] = ...
                statsMultipleEventByCondition(intervalStopData, conditionInfo);
            
            as = as.initialize();
  
            function [mn, mx, avg] = statsSingleEvent(data)
                if isempty(data)
                    [mn, mx, avg] = deal(nan(size(data, 2), 1));
                else
                    mn = nanmin(data, [], 1)';
                    mx = nanmax(data, [], 1)';
                    avg = nanmean(data, 1)';
                end
            end
            
            % internal fn to compute the min and max and mean on a simple
            % cell of vectors (scalar events)
            function [mn, mx, avg] = statsSingleEventByCondition(dataCell)
                % dataCell is nConditions x 1 cell with nTrials x
                % nOccurrences matrices
                % mn, mx, avg are nConditions x 1 cells with nOccurrence x 1
                % vectors
                
                [mn, mx, avg] = cellfun(@statsSingleEvent, dataCell);
            end
            
            function [mn, mx, avg] = statsMultipleEvent(dataCell)
                % dataCell is a nDistinctEvents (e.g. nMarks, nIntervals) cell, 
                % each of which is an nTrials x nOccurrences
                % mn, mx, avg are nDistinctEvents cell,
                % each of which is an nOccurrences vectors
                
                [mn, mx, avg] = cellfun(@statsSingleEvent, dataCell, 'UniformOutput', false);
            end

            function [mn, mx, avg] = statsMultipleEventByCondition(dataCell, ci)
                % dataCell is a nDistinctEvents (e.g. nMarks, nIntervals) cell, 
                % each of which is an nTrials x nOccurrences, to be grouped
                % into conditions by ci
                %
                % mn, mx, avg are nDistinctEvents cell,
                % each of which is an nConditions x nOccurrences matrix
                nEvents = numel(dataCell);
                nConditions = ci.nConditions;
                [mn, mx, avg] = deal(cell(nEvents, 1));
                
                if nEvents == 0
                    return;
                end
                
                for iE = 1:nEvents
                    nOccurrences = size(dataCell{iE}, 2);
                    dataGrouped = ci.groupElementsFlattened(dataCell{iE});
                    [mn{iE}, mx{iE}, avg{iE}] = deal(nan(nConditions, nOccurrences));
                    for iC = 1:nConditions
                        [mn{iE}(iC, :), mx{iE}(iC, :), avg{iE}(iC, :)] = ...
                            statsSingleEvent(dataGrouped{iC});
                    end
                end
            end
        end
        
        function as = buildByAggregation(alignSummarySet)
            % build a new AlignSummary object by aggregating over multiple
            % objects
            
            if iscell(alignSummarySet)
                set = makecol([alignSummarySet{:}]);
            else
                set = makecol(alignSummarySet);
            end
            
            as = AlignSummary();
            as.alignDescriptor = set(1).alignDescriptor;
            as.conditionDescriptor = set(1).conditionDescriptor;
            
            % TODO could check that all alignDescriptors and
            % conditionDescriptors are equivalent here, but would be slow
            aggNTrials = makecol([set.nTrials]); % used in nested functions below
            
            % add up trial counts
            as.nTrials = sum(aggNTrials);
            
            [as.startMin, as.startMax, as.startMean] = ...
                aggregateSingleEventStats([set.startMin], [set.startMax], [set.startMean], aggNTrials);
            [as.stopMin, as.stopMax, as.stopMean] = ...
                aggregateSingleEventStats([set.stopMin], [set.stopMax], [set.stopMean], aggNTrials);
            
            % markMax is nMarks x 1, cat(2, set.markMax) is nMarks x
            % nSummary cell arrays. Contents are nOccurrences x 1 vectors
            [as.markMax, as.markMin, as.markMean] = aggregateMultipleEventStats(...
                cat(2, set.markMax), cat(2, set.markMin), ...
                cat(2, set.markMean), aggNTrials);
            
            [as.intervalStartMax, as.intervalStartMin, as.intervalStartMean] = aggregateMultipleEventStats(...
                cat(2, set.intervalStartMax), cat(2, set.intervalStartMin), ...
                cat(2, set.intervalStartMean), aggNTrials);
            
            [as.intervalStopMax, as.intervalStopMin, as.intervalStopMean] = aggregateMultipleEventStats(...
                cat(2, set.intervalStopMax), cat(2, set.intervalStopMin), ...
                cat(2, set.intervalStopMean), aggNTrials);
    
            % nConditions x nSummary matrix of trial counts for doing
            % proper re-weighting
            nTrialsByConditionMat = cat(2, [set.nTrialsByCondition]);
            
            % add up trial counts
            as.nTrialsByCondition = sum(nTrialsByConditionMat, 2);
            
            % args are nConditions x nSummary matrices
            [as.startMinByCondition, as.startMaxByCondition, as.startMeanByCondition] = ...
                aggregateSingleEventStatsByCondition(cat(2, set.startMinByCondition), ...
                cat(2, set.startMaxByCondition), cat(2, set.startMeanByCondition), ...
                nTrialsByConditionMat);
            
            [as.stopMinByCondition, as.stopMaxByCondition, as.stopMeanByCondition] = ...
                aggregateSingleEventStatsByCondition(cat(2, set.stopMinByCondition), ...
                cat(2, set.stopMaxByCondition), cat(2, set.stopMeanByCondition), ...
                nTrialsByConditionMat);
            
            % args are nDistinctEvents (e.g. nMarks, nIntervals) x
            % nSummary cells with nCondition x nOccurrence matrices inside
            [as.markMaxByCondition, as.markMinByCondition, as.markMeanByCondition] = ...
                aggregateMultipleEventStatsByCondition(cat(2, set.markMaxByCondition), ...
                cat(2, set.markMinByCondition), cat(2, set.markMeanByCondition), ...
                nTrialsByConditionMat);
            
            [as.intervalStartMaxByCondition, as.intervalStartMinByCondition, as.intervalStartMeanByCondition] = ...
                aggregateMultipleEventStatsByCondition(cat(2, set.intervalStartMaxByCondition), ...
                cat(2, set.intervalStartMinByCondition), cat(2, set.intervalStartMeanByCondition), ...
                nTrialsByConditionMat);
            
            [as.intervalStopMaxByCondition, as.intervalStopMinByCondition, as.intervalStopMeanByCondition] = ...
                aggregateMultipleEventStatsByCondition(cat(2, set.intervalStopMaxByCondition), ...
                cat(2, set.intervalStopMinByCondition), cat(2, set.intervalStopMeanByCondition), ...
                nTrialsByConditionMat);
            
            as = as.initialize();
            
            function [maxNew, minNew, meanNew] = aggregateSingleEventStats(...
                    maxData, minData, meanData, nTrialsData)
                minNew = nanmin(minData);
                maxNew = nanmax(maxData);
                meanNew = nansum(makecol(meanData) .* makecol(nTrialsData)) / sum(nTrialsData);
            end
            
            function [maxNew, minNew, meanNew] = aggregateSingleEventStatsByCondition(...
                    maxData, minData, meanData, nTrialsMat)
                [maxNew, minNew, meanNew] = deal(nanvec(size(maxData, 1)));
                for iC = 1:size(maxData, 1)
                    [maxNew(iC), minNew(iC), meanNew(iC)] = ...
                        aggregateSingleEventStats(maxData(iC, :), minData(iC, :), ...
                        meanData(iC, :), nTrialsMat(iC, :));
                end
            end
            
            function [maxNew, minNew, meanNew] = aggregateMultipleEventStats(...
                    maxData, minData, meanData, nTrialsData)
                % max/min/meanData are nDistinctEvents x nSummary cells of
                % nOccurrences vectors.
                %
                % nTrialsData is nSummary x 1 vector
                % 
                % max/min/meanNew are nDistinctEvents cells of nOccurrences
                % vectors
                nDistinctEvents = size(maxData, 1);
                nSummary = size(maxData, 2);
                nOccurrences = cellfun(@numel, maxData);
                maxOccurrencesByEvent = max(nOccurrences, [], 2);
                
                [maxNew, minNew, meanNew] = deal(cell(nDistinctEvents, 1));
                
                for iEv = 1:nDistinctEvents
                    padToLength = @(vec) [makecol(vec); ...
                        nan(maxOccurrencesByEvent(iEv)-numel(vec), 1)];
                    % *Mat is maxOccurrencesByEvent x nSummary
                    maxMat = cell2mat(cellfun(padToLength, maxData(iEv, :), ...
                        'UniformOutput', false));
                    minMat = cell2mat(cellfun(padToLength, minData(iEv, :), ...
                        'UniformOutput', false));
                    meanMat = cell2mat(cellfun(padToLength, meanData(iEv, :), ...
                        'UniformOutput', false));
                    
                    % cell elements are maxOccurrencesByEvent x 1 vectors
                    maxNew{iEv} = nanmax(maxMat, [], 2);
                    minNew{iEv} = nanmin(minMat, [], 2);
                    
                    % note that we use nanmean to compute the weighted sum
                    % because nansum returns 0 when all are NaN
                    meanNew{iEv} = nanmean(bsxfun(@times, meanMat, makerow(nTrialsData)), 2) / ...
                        sum(nTrialsData / nSummary);
                end
            end
            
            function [maxNew, minNew, meanNew] = aggregateMultipleEventStatsByCondition(...
                    maxData, minData, meanData, nTrialsData)
                % max/min/meanData are nMarks x nSummary cells with 
                % nConditions x nOccurrence matrices inside
                %
                % nTrials Data is nConditions x nSummary matrix
                %
                % max/min/meanNew are nMarks cell arrays with 
                % nConditions x nOccurrence matrices inside
                
                nDistinctEvents = size(maxData, 1);
                nSummary = size(maxData, 2);
                
                % nMarks x nSummary
                nOccurrences = cellfun(@(x) size(x, 2), maxData);
                % nMarks x 1
                maxOccurrencesByEvent = max(nOccurrences, [], 2);
                
                % nConditions x 1 x nSummary
                nTrialsReshaped = permute(nTrialsData, [1 3 2]);
                nTrialsTotalByCondition = sum(nTrialsData, 2);
                
                [maxNew, minNew, meanNew] = deal(cell(nDistinctEvents, 1));
                
                for iEv = 1:nDistinctEvents
                    padToWidth = @(mat) [mat, ...
                        nan(size(mat, 1), maxOccurrencesByEvent(iEv)-size(mat, 2))];
                    
                    % output of cellfun is 1 x 1 x nSummary.
                    %   contents are nConditions x maxOccurrences.
                    % output of cell2mat is nConditions x maxOccurrences x nSummary
                    maxMat = cell2mat(cellfun(padToWidth, shiftdim(maxData(iEv, :), -1), ...
                        'UniformOutput', false));
                    minMat = cell2mat(cellfun(padToWidth, shiftdim(minData(iEv, :), -1), ...
                        'UniformOutput', false));
                    meanMat = cell2mat(cellfun(padToWidth, shiftdim(meanData(iEv, :), -1), ...
                        'UniformOutput', false));
                    
                    % maxNew{iEv} is nConditions x maxOccurrences
                    maxNew{iEv} = nanmax(maxMat, [], 3);
                    minNew{iEv} = nanmin(minMat, [], 3);
                    
                    % meanMat is nConditions x maxOccurrences x nSummary
                    % output of nansum is nConditions x maxOccurrences
                    % nTrialsTotalByCondition is nConditions x 1
                    % 
                    % note that we use nanmean to compute the weighted sum
                    % because nansum returns 0 when all are NaN
                    meanNew{iEv} = bsxfun(@rdivide, nanmean(bsxfun(@times, meanMat, nTrialsReshaped), 3), ...
                        nTrialsTotalByCondition / nSummary);
                end
            end
           
        end
        
%         function as = buildForSelectedConditions(aso, cmask)
%             % build a new AlignSummary object by including only selected
%             % conditions
%             error('Not fully implemented');
%             
%             as = AlignSummary();
%             as.alignDescriptor = aso.alignDescriptor;
%             as.conditionDescriptor = aso.conditionDescriptor;
%             
%             % mask all of the byConditions directly by cmask
%             as.nTrialsByCondition = aso.nTrialsByCondition(cmask);
%             as.startMinByCondition =  aso.startMinByCondition(cmask);
%             as.startMaxByCondition =  aso.startMaxByCondition(cmask);
%             as.startMeanByCondition = as.startMeanByCondition(cmask);
%             as.stopMinByCondition = as.stopMinByCondition(cmask);
%             as.stopMaxByCondition = as.stopMaxByCondition(cmask);
%             as.stopMeanByCondition = as.stopMeanByCondition(cmask);
% 
%             applyCmaskFn = @(in) cellfun(@(e) e(cmask, :);
%             as.markMaxByCondition = as.markMaxByCondition(cmask);
%             as.markMinByCondition = as.markMinByCondition(cmask);
%             as.markMeanByCondition = as.markMeanByCondition(cmask);
%             as.intervalStartMaxByCondition = as.intervalStartMaxByCondition(cmask);
%             as.intervalStartMinByCondition = as.intervalStartMinByCondition(cmask);
%             as.intervalStartMeanByCondition = as.intervalStartMeanByCondition(cmask);
%             as.intervalStopMaxByCondition = as.intervalStopMaxByCondition(cmask);
%             as.intervalStopMinByCondition = as.intervalStopMinByCondition(cmask);
%             as.intervalStopMeanByCondition = as.intervalStopMeanByCondition(cmask);
% 
%             % aggregate the selected conditions into the primary statistics
%             aggNTrials = as.nTrialsByCondition; % used in nested functions below
%             as.nTrials = sum(as.nTrialsByCondition);
%             
%             [as.startMin, as.startMax, as.startMean] = ...
%                 aggregateSingleEventStats(as.startMinByCondition, as.startMaxByCondition, as.startMeanByCondition, aggNTrials);
%             [as.stopMin, as.stopMax, as.stopMean] = ...
%                 aggregateSingleEventStats(as.stopMinByCondition, as.stopMaxByCondition, as.stopMeanByCondition, aggNTrials);
%             
%             % aggregate
%             % markMaxByCondition is nMarks x 1 of nConditions x nOccurrences,
%             % cat(1, as.markMaxByCondition{:})' is nOccurrences x nConditions
%             % nSummary cell arrays. Contents are nOccurrences x 1 vectors
%             [as.markMax, as.markMin, as.markMean] = aggregateMultipleEventStats(...
%                 cat(2, set.markMax), cat(2, set.markMin), ...
%                 cat(2, set.markMean), aggNTrials);
%             
%             [as.intervalStartMax, as.intervalStartMin, as.intervalStartMean] = aggregateMultipleEventStats(...
%                 cat(2, set.intervalStartMax), cat(2, set.intervalStartMin), ...
%                 cat(2, set.intervalStartMean), aggNTrials);
%             
%             [as.intervalStopMax, as.intervalStopMin, as.intervalStopMean] = aggregateMultipleEventStats(...
%                 cat(2, set.intervalStopMax), cat(2, set.intervalStopMin), ...
%                 cat(2, set.intervalStopMean), aggNTrials);
%     
%             as = as.initialize();
%             
%             function [maxNew, minNew, meanNew] = aggregateSingleEventStats(...
%                     maxData, minData, meanData, nTrialsData)
%                 minNew = nanmin(minData);
%                 maxNew = nanmax(maxData);
%                 meanNew = nansum(makecol(meanData) .* makecol(nTrialsData)) / sum(nTrialsData);
%             end
%             
%             function [maxNew, minNew, meanNew] = aggregateMultipleEventStats(...
%                     maxData, minData, meanData, nTrialsData)
%                 % max/min/meanData are nDistinctEvents x nSummary cells of
%                 % nOccurrences vectors.
%                 %
%                 % nTrialsData is nSummary x 1 vector
%                 % 
%                 % max/min/meanNew are nDistinctEvents cells of nOccurrences
%                 % vectors
%                 nDistinctEvents = size(maxData, 1);
%                 nSummary = size(maxData, 2);
%                 nOccurrences = cellfun(@numel, maxData);
%                 maxOccurrencesByEvent = max(nOccurrences, [], 2);
%                 
%                 [maxNew, minNew, meanNew] = deal(cell(nDistinctEvents, 1));
%                 
%                 for iEv = 1:nDistinctEvents
%                     padToLength = @(vec) [makecol(vec); ...
%                         nan(maxOccurrencesByEvent(iEv)-numel(vec), 1)];
%                     % *Mat is maxOccurrencesByEvent x nSummary
%                     maxMat = cell2mat(cellfun(padToLength, maxData(iEv, :), ...
%                         'UniformOutput', false));
%                     minMat = cell2mat(cellfun(padToLength, minData(iEv, :), ...
%                         'UniformOutput', false));
%                     meanMat = cell2mat(cellfun(padToLength, meanData(iEv, :), ...
%                         'UniformOutput', false));
%                     
%                     % cell elements are maxOccurrencesByEvent x 1 vectors
%                     maxNew{iEv} = nanmax(maxMat, [], 2);
%                     minNew{iEv} = nanmin(minMat, [], 2);
%                     
%                     % note that we use nanmean to compute the weighted sum
%                     % because nansum returns 0 when all are NaN
%                     meanNew{iEv} = nanmean(bsxfun(@times, meanMat, makerow(nTrialsData)), 2) / ...
%                         sum(nTrialsData / nSummary);
%                 end
%             end
%         end
    end

    methods(Access=protected) % Builds internal properties at construction time
        function as = initialize(as)
            assert(nargout == 1);
            as = as.buildLabelInfo();
            as = as.buildIntervalInfo();
        end
        
        function as = buildLabelInfo(as, varargin)
            % build a list of events to mark on the time axis or on data by
            % aggregating across the start, stop, zero, and marks. 
            % each mark will be expanded so that one label will be
            % generated for each mark
            
            assert(nargout == 1);
           
            % optionally provide time window which filters which labels will be included
            p = inputParser();
            p.addParamValue('timeWindow', [], @isvector);
            p.parse(varargin{:});
            timeWindow = p.Results.timeWindow;

            ad = as.alignDescriptor;
            nConditions = as.conditionDescriptor.nConditions;

            info = struct('name', {}, 'time', {}, 'min', {}, 'max', {}, 'appear', {}, 'fixed', {});
            counter = 1;

            % include the zero event provided that it lies within the start/stop window
            if ad.zeroMark
                info(counter).name = ad.zeroLabel; 
                info(counter).time = 0;
                info(counter).min = 0;
                info(counter).max = 0;
                info(counter).timeByCondition = zeros(nConditions, 1);
                info(counter).minByCondition = zeros(nConditions, 1);
                info(counter).maxByCondition = zeros(nConditions, 1);
                info(counter).appear = ad.zeroAppear;
                info(counter).fixed = true;
                
                counter = counter + 1;
            end
            
%             % label the start event
%             if ad.startMark
%                 info(counter).name = ad.startLabel;
%                 info(counter).time = as.startMean;
%                 info(counter).min = as.startMin;
%                 info(counter).max = as.startMax;
%                 info(counter).timeByCondition = as.startMeanByCondition;
%                 info(counter).minByCondition = as.startMinByCondition;
%                 info(counter).maxByCondition = as.startMaxByCondition;
%                 info(counter).appear = ad.startAppear;
%                 info(counter).fixed = ad.isStartFixedTime;
%                 
%                 counter = counter + 1;
%             end

%             % label the stop event
%             if ad.stopMark
%                 info(counter).name = ad.stopLabel;
%                 info(counter).time = as.stopMean;
%                 info(counter).min = as.stopMin;
%                 info(counter).max = as.stopMax;
%                 info(counter).timeByCondition = as.stopMeanByCondition;
%                 info(counter).minByCondition = as.stopMinByCondition;
%                 info(counter).maxByCondition = as.stopMaxByCondition;
%                 info(counter).appear = ad.stopAppear;
%                 info(counter).fixed = ad.isStopFixedTime;
%                 
%                 counter = counter + 1;
%             end

            % label each of the event marks that are fixed with respect to the zero event
            for iMark = 1:ad.nMarks
                if ~ad.markShowOnAxis(iMark), continue; end
                % loop over each occurrence of the mark
                for iOccur = 1:numel(as.markMean{iMark})
                    info(counter).name = ad.markLabels{iMark};
                    info(counter).time = as.markMean{iMark}(iOccur);
                    info(counter).min = as.markMin{iMark}(iOccur);
                    info(counter).max = as.markMax{iMark}(iOccur);
                    info(counter).timeByCondition = as.markMeanByCondition{iMark}(:, iOccur);
                    info(counter).minByCondition = as.markMinByCondition{iMark}(:, iOccur);
                    info(counter).maxByCondition = as.markMaxByCondition{iMark}(:, iOccur);
                    info(counter).appear = ad.markAppear{iMark};
                    info(counter).fixed = ad.isMarkFixedTime(iMark);
                
                    counter = counter + 1;
                end
            end
            
            if ~isempty(timeWindow)
                times = [info.time];
                timeMask = times >= timeWindow(1) & times <= timeWindow(2);
                info = info(timeMask);
            end
            
            as.labelInfo = makecol(info);
        end
        
        function as = buildIntervalInfo(as, varargin)
            assert(nargout == 1);
        
            ad = as.alignDescriptor;
            
            info = struct('name', {}, 'startTime', {}, 'startMin', {}, 'startMax', {}, 'appear', {}, 'fixed', {});
            counter = 1;
            for iInterval = 1:ad.nIntervals
                if ~ad.intervalShowOnAxis(iInterval), continue; end
                for iOccur = 1:numel(as.intervalStartMean{iInterval})
                    info(counter).name = ad.intervalLabels{iInterval};
                    info(counter).startTime = as.intervalStartMean{iInterval}(iOccur);
                    info(counter).startMin = as.intervalStartMin{iInterval}(iOccur);
                    info(counter).startMax = as.intervalStartMax{iInterval}(iOccur);
                    info(counter).stopTime = as.intervalStopMean{iInterval}(iOccur);
                    info(counter).stopMin = as.intervalStopMin{iInterval}(iOccur);
                    info(counter).stopMax = as.intervalStopMax{iInterval}(iOccur);
                    info(counter).startTimeByCondition = as.intervalStartMeanByCondition{iInterval}(:, iOccur);
                    info(counter).startMinByCondition = as.intervalStartMinByCondition{iInterval}(:, iOccur);
                    info(counter).startMaxByCondition = as.intervalStartMaxByCondition{iInterval}(:, iOccur);
                    info(counter).stopTimeByCondition = as.intervalStopMeanByCondition{iInterval}(:, iOccur);
                    info(counter).stopMinByCondition = as.intervalStopMinByCondition{iInterval}(:, iOccur);
                    info(counter).stopMaxByCondition = as.intervalStopMaxByCondition{iInterval}(:, iOccur);
                    info(counter).appear = ad.intervalAppear{iInterval};
                    info(counter).fixed = ad.isIntervalFixedTime(iInterval);
                    counter = counter + 1;
                end
            end
            
            as.intervalInfo = info;
        end
    end
    
    methods
        function au = setupTimeAutoAxis(as, varargin)
            % add ticks and markers to the x-axis of a plot representing
            % all marks and intervals for this align descriptor
            p = inputParser();
            p.addParamValue('which', 'x', @(x) ismember(x, {'x', 'y', 'z'}));
            p.addParamValue('axh', [], @(x) isempty(x) || isscalar(x));
            p.addParamValue('tOffsetZero', 0, @isscalar); % x position of t=0 on the axis
            p.addParamValue('style', 'tickBridge', @ischar); % 'tickBridge' or 'marker'
            p.addParamValue('tMin', as.startMin, @isscalar); % time minimum for style 'tickBridge'
            p.addParamValue('tMax', as.stopMax, @isscalar); % time maximum for style 'tickBridge'
            p.addParamValue('showRanges', true, @islogical); % show gray intervals indicating the range of each label / interval
            p.addParamValue('allowedRange', 0, @isscalar); % allowed size of min - max range before surrounding label with < >
            p.parse(varargin{:});

            style = p.Results.style;
            xOffset = p.Results.tOffsetZero;
            tMin = p.Results.tMin;
            tMax = p.Results.tMax;
            allowedRange = p.Results.allowedRange;
            showRanges = p.Results.showRanges;
            
            au = AutoAxis(p.Results.axh);
            au.xUnits = as.timeUnitName;
            
            % filter labels, intervals that overlap tMin : tMax
            labelInfo = as.labelInfo; %#ok<*PROP>
            if ~isempty(labelInfo)
                labelInfo = labelInfo([labelInfo.time] >= tMin & [labelInfo.time] <= tMax); 
            end
            intervalInfo = as.intervalInfo;
            if ~isempty(intervalInfo)
                intervalInfo = intervalInfo([intervalInfo.stopTime] >= tMin & [intervalInfo.startTime] <= tMax);
            end
            
            switch style
                case 'tickBridge'      
                    % include tMin and tMax ticks
                    ticks = [tMin, tMax, labelInfo.time]' + xOffset; 
                    labels = cellvec(numel(labelInfo));
                    
                    % wrap labels with some range to their occurrences with < >
                    for iLabel = 1:numel(labelInfo)
                        if labelInfo(iLabel).max - labelInfo(iLabel).min <= allowedRange
                            labels{iLabel} = labelInfo(iLabel).name;
                        else
                            labels{iLabel} = sprintf('<%s>', labelInfo(iLabel).name);
                        end
                    end
                    tickLabels = cat(1,{sprintf('%g', tMin); sprintf('%g', tMax)}, labels);
                    tickAlignment = cat(1, {'left'; 'right'}, repmat({'center'}, numel(labels), 1)); 
                    
                    % remove tMin and/or tMax if redundant
                    tickMask = true(size(ticks));
                    if any(ticks(3:end) == tMin)
                        tickMask(1) = false;
                        tickAlignment(ticks==tMin) = {'left'};
                    end
                    if any(ticks(3:end) == tMax)
                        tickMask(2) = false;
                        tickAlignment(ticks==tMax) = {'right'};
                    end
                    ticks = ticks(tickMask);
                    tickLabels = tickLabels(tickMask);
                    tickAlignment = tickAlignment(tickMask);
                    
                    au.addTickBridge('x', 'tick', ticks, 'tickLabel', tickLabels, 'tickAlignment', tickAlignment); 
                    
                case 'marker'
                    for iInterval = 1:numel(intervalInfo)
                        ii = intervalInfo(iInterval);
                        
                        % constrain to tMin:tMax
                        if ii.startTime < tMin, ii.startTime = tMin; end
                        if ii.startMin < tMin, ii.startMin = tMin; end
                        if ii.stopTime > tMax, ii.stopTime = tMax; end
                        if ii.stopMax > tMax, ii.stopMax = tMax; end
                        
                        if showRanges
                            errorInterval = [ii.startMin, ii.stopMax] + xOffset;
                        else
                            errorInterval = [];
                        end
                        cvec = ii.appear.Color;
                        errorColor = AppearanceSpec.desaturateColor(cvec, 0.5);
                        au.addIntervalX([ii.startTime, ii.stopTime] + xOffset, ii.name, ...
                            'errorInterval', errorInterval, 'errorIntervalColor', errorColor, ...
                            'color', cvec);
                    end
                    
                    for iLabel = 1:numel(labelInfo)
                        li = labelInfo(iLabel);  
                        
                        % constrain to tMin:tMax
                        if li.min < tMin, li.min = tMin; end
                        if li.max > tMax, li.max = tMax; end
                            
                        if showRanges
                            errorInterval = [li.min, li.max] + xOffset;
                        else
                            errorInterval = [];
                        end
                        cvec = li.appear.Color;
                        errorColor = AppearanceSpec.desaturateColor(cvec, 0.5);
                        au.addMarkerX(li.time + xOffset, li.name, ...
                            'interval', errorInterval, ...
                            'markerColor', cvec, 'intervalColor', errorColor);
                    end
                    
                    au.addAutoScaleBarX();
            end
            axis off;
            au.update();
            au.installCallbacks();      
        end

%         function drawOnTimeseries(as, data, tvec, varargin)
%         % annotate data time-series with markers according to the labels indicated
%         % by this AlignSummary
%         %
%         % data is T x D x N matrix
%         % tvec is T x 1
%         %
%         % where
%         % D is data dimensionality, 1 or 2 or 3
%         % T is number of time points
%         % N is the number of traces to be annotated
%             p = inputParser();
%             p.addParamValue('drawLegend', false, @islogical);
%             p.parse(varargin{:});
%             drawLegend = p.Results.drawLegend;
%             
%             T = size(data, 1);
%             D = size(data, 2);
%             % N = size(data, 3);
%             assert(isvector(tvec) && numel(tvec) == T, 'tvec must be vector with length == size(data, 2)');
%             assert(D >= 1 && D <= 3, 'Dimensionality of timeseries, size(data, 2), must be 1,2,3');
% 
%             hold on
% 
%             nLabels = numel(as.labelInfo);
%             hleg = nan(nLabels, 1);
%             legstr = cell(nLabels, 1);
%             
%             labelTimes = [ad.labelInfo.time];
%             
%             % nLabels x D x N
%             labelPositions = interp1(tvec, data, labelTimes, 'linear');
%             
%             for iLabel = 1:nLabels
%                 info = ad.labelInfo(iLabel);
%                 legstr{iLabel} = info.name;
%                 plotArgs = info.appear.getPlotArgs();
%                 
%                 if D == 1
%                     hleg(iLabel) = plot(labelTimes(1), squeeze(labelPositions(iLabel, 1, :)), ...
%                         'k.', 'MarkerSize', 10, plotArgs{:});
%                 elseif D == 2
%                     hleg(iLabel) = plot(squeeze(labelPositions(iLabel, 1, :)), squeeze(labelPositions(iLabel, 2, :)), ...
%                         'k.', 'MarkerSize', 10, plotArgs{:});
%                 else
%                     hleg(iLabel) = plot3(squeeze(labelPositions(iLabel, 1, :)), ...
%                         squeeze(labelPositions(iLabel, 2, :)), ...
%                         squeeze(labelPositions(iLabel, 3, :)), ...
%                         'k.', 'MarkerSize', 10, plotArgs{:});
%                 end
%             end
%                 
%             if drawLegend
%                 legend(hleg, legstr, 'Location', 'NorthEast');
%                 legend boxoff;
%             end
%         end
%         
        function drawOnDataByCondition(as, time, data, varargin)
        % annotate data time-series with markers according to the labels indicated
        % by this AlignSummary, on a per-condition basis
        %
        % Inputs have one of the following formats:
        %  all timeseries have same length:
        %    data is T x D x C x N matrix
        %    time is T x 1  vector
        %
        %  or timeseries have different lengths:
        %    data is C x 1 cell of T x D x N matrices
        %    time is C x 1 cell of T x 1 vectors
        %
        % where
        %   D is data dimensionality, 1 or 2 or 3
        %   T is number of time points
        %   C is number of conditions (masked by conditionIdx)
        %   N is the number of traces to be annotated (with the same time)
        
            p = inputParser();
            p.addParamValue('includeInLegend', false, @islogical);
            p.addParamValue('tOffsetZero', 0, @isscalar);
            p.addParamValue('conditionIdx', truevec(as.conditionDescriptor.nConditions), @isvector);
            p.addParamValue('axh', gca, @ishandle);
            p.addParamValue('tMin', -Inf, @isscalar);
            p.addParamValue('tMax', Inf, @isscalar);
            p.addParamValue('alpha', 1, @isscalar);
            p.addParamValue('markAlpha', 1, @isscalar);
            p.addParamValue('markSize', 5, @isscalar);
            p.addParamValue('showInLegend', true, @islogical);
            p.addParamValue('useTranslucentMark3d', true, @islogical);
%             p.addParamValue('markErrorAlpha', 1, @isscalar);
            p.addParamValue('markShowRanges', false, @islogical);
            p.parse(varargin{:});
            
            tOffsetZero = p.Results.tOffsetZero;
            axh = p.Results.axh;
            
            conditionIdx = p.Results.conditionIdx;
            if islogical(conditionIdx)
                conditionIdx = find(conditionIdx);
            end
            nConditions = numel(conditionIdx);
            
            if iscell(data)
                assert(isvector(data) && iscell(time) && isvector(time), 'Cell inputs must be vectors');
                C = numel(data);
                D = size(data{1}, 2);
            else
                T = size(data, 1);
                D = size(data, 2);
                C = size(data, 3);
                %N = size(data, 4);

                assert(~iscell(time) && isvector(time) && numel(time) == T, 'Time vector must be size(data, 1)');
                assert(D >= 1 && D <= 3, 'Dimensionality of timeseries, size(data, 2), must be 1,2,3');
                assert(C == nConditions, 'size(data, 3) must match nConditions specified');
            end
            
            hold(axh, 'on');
            
            % plot intervals
            hIntervals = cell(as.nIntervals, 1);
            nOccurByInterval = as.nOccurrencesByInterval;
            for iInterval = 1:as.nIntervals
                % gather mark locations
                % nOccur x nConditions cell of T x D data in interval
                [intLoc, intRangeLoc] = deal(cell(nOccurByInterval(iInterval), as.nConditions)); 
                for iCond = 1:C
                    idxCond = conditionIdx(iCond);
                    % filter by the time window specified (for this condition)
                    % tStart/tStop will be nOccur x 1
                    tStart = as.intervalStartMeanByCondition{iInterval}(idxCond, :)';
                    tStop = as.intervalStopMeanByCondition{iInterval}(idxCond, :)';;
                    tRangeStart = as.intervalStartMinByCondition{iInterval}(idxCond, :)';
                    tRangeStop = as.intervalStopMaxByCondition{iInterval}(idxCond, :)';;
                    
                    % tvec should T vector, dmat should be T x D 
                    if iscell(time)
                        tvec = time{iCond};
                    else
                        tvec = time;
                    end
                    if iscell(data)
                        dmat = data{iCond};
                    else
                        % data is T x D x C matrix
                        dmat = TensorUtils.squeezeDims(data(:, :, iCond, :), 3);
                    end
                    
                    % constrain the time window to the interval being
                    % plotted as defined by tvec
                    valid = ~isnan(tStart) & ~isnan(tStop);
                    valid(tStart > max(tvec)) = false;
                    valid(tStop < min(tvec)) = false;
                    
                    if ~any(valid), continue; end
                    
                    tStart(tStart < min(tvec)) = min(tvec);
                    tStop(tStop > max(tvec)) = max(tvec);
                    tRangeStart(tRangeStart < min(tvec)) = min(tvec);
                    tRangeStop(tRangeStop > max(tvec)) = max(tvec);
                    
                    % and slice the interval location
                    % tStart, tStop is nOccur x 1
                    % dInterval will be nOccur cell with T x D values
                    dInterval = TrialDataUtilities.Plotting.DrawOnData.sliceIntervalLocations(tvec, dmat, tStart, tStop);
                    intLoc(:, iCond) = dInterval;
                    
                    dIntervalRange = TrialDataUtilities.Plotting.DrawOnData.sliceIntervalLocations(tvec, dmat, tRangeStart, tRangeStop);
                    intRangeLoc(:, iCond) = dIntervalRange;
                end
 
                 % add the time offset if plotting against time
                if D == 1
                    for i = 1:numel(intLoc)
                        if isempty(intLoc{i}), continue; end;
                        intLoc{i}(:, 1, :) = intLoc{i}(:, 1, :) + tOffsetZero;
                        intRangeLoc{i}(:, 1, :) = intRangeLoc{i}(:, 1, :) + tOffsetZero;
                    end
                end
                
                app = as.alignDescriptor.intervalAppear{iInterval};
                
                % first plot range interval and suppress from legend
                if p.Results.markShowRanges
                    errorThickness = p.Results.markSize * 0.5;
                    errorAppear = app;
                    errorAppear.Color = AppearanceSpec.desaturateColor(errorAppear.Color, 0.5);
                    h = TrialDataUtilities.Plotting.DrawOnData.plotInterval(axh, intRangeLoc, D, ...
                        errorAppear, errorThickness, p.Results.markAlpha);
                    TrialDataUtilities.Plotting.hideInLegend(h);
                end
                
                % then plot interval
                hIntervals{iInterval} = TrialDataUtilities.Plotting.DrawOnData.plotInterval(axh, intLoc, D, ...
                    app, p.Results.markSize, p.Results.markAlpha);
                                
                if p.Results.showInLegend
                    TrialDataUtilities.Plotting.showFirstInLegend(hIntervals{iInterval}, as.alignDescriptor.intervalLabels{iInterval});
                else
                    TrialDataUtilities.Plotting.hideInLegend(hIntervals{iInterval});
                end
            end

            nMarks = as.nMarks;
            
            % markMeanByCondition is nMarks x 1 cell with nConditions x 
            % nOccurrences matrices.
            % for each mark we want to find where to plot the mean/min/max
            % location of each occurrence on the data via interpolation
            % we assemble this in a nConditions x nOccurrences x 2or3 matrix
            % of locations
            nOccurByMark = as.nOccurrencesByMark;
            for iMark = 1:nMarks
                markMeanLoc = nan(nOccurByMark(iMark), max(2, D), nConditions);
                markErrorLoc = cell(nOccurByMark(iMark), nConditions);
                
                for iC = 1:nConditions
                    % get the mark times to plot
                    c = conditionIdx(iC);
                    tMarkMean = as.markMeanByCondition{iMark}(c, :)';
                    tMarkMin = as.markMinByCondition{iMark}(c, :)';
                    tMarkMax = as.markMaxByCondition{iMark}(c, :)';
                    
                    % filter by the time window specified
                    maskInvalid = tMarkMean < p.Results.tMin | tMarkMean > p.Results.tMax;
                    tMarkMean(maskInvalid) = NaN;
                    tMarkMin(maskInvalid) = NaN;
                    tMarkMax(maskInvalid) = NaN;
                    
                    if all(isnan(tMarkMean))
                        % none found for this condition
                        continue;
                    end
                    
                    % get the position along the timeseries via
                    % interpolation
                    % d will be T x D x N, t will be T x 1;
                    if iscell(data)
                        d = data{iC};
                        t = time{iC};
                    else
                        d = TensorUtils.squeezeDims(data(:, :, iC, :), 3);
                        t = time;
                    end
                    
                    % dMean/dMin/dMax will be nOccur x max(2,D) x 1
                    % since time will become dMean(:, 1, :) if D == 1
                    dMean = TrialDataUtilities.Plotting.DrawOnData.interpMarkLocation(t, d, tMarkMean);
                    
                    % permute to be D x nOccur
                    markMeanLoc(:, :, iC) = dMean;
                    
                    % and slice the error interval location
                    % tMarkMin is nOcccur x 1
                    % dError will be nOccur cell with 
                    dError = TrialDataUtilities.Plotting.DrawOnData.sliceIntervalLocations(t, d, tMarkMin, tMarkMax);
                    markErrorLoc(:, iC) = dError;
                end
                
                % add the time offset if plotting against time
                if D == 1
                    markMeanLoc(:, 1, :) = markMeanLoc(:, 1, :) + tOffsetZero;
                    for i = 1:numel(markErrorLoc)
                        if isempty(markErrorLoc{i}), continue; end;
                        markErrorLoc{i}(:, 1) = markErrorLoc{i}(:, 1) + tOffsetZero;
                    end
                end
                
                app = as.alignDescriptor.markAppear{iMark};
                
                % plot mark error interval and suppress from legend
                if p.Results.markShowRanges
                    errorThickness = p.Results.markSize * 0.25;
                    errorAppear = app;
                    errorAppear.Color = AppearanceSpec.desaturateColor(errorAppear.Color, 0.5);
                    h = TrialDataUtilities.Plotting.DrawOnData.plotInterval(axh, markErrorLoc, D, ...
                        errorAppear, errorThickness, p.Results.markAlpha);
                    TrialDataUtilities.Plotting.hideInLegend(h);
                end
                
                % plot mark and provide legend hint
                h = TrialDataUtilities.Plotting.DrawOnData.plotMark(axh, markMeanLoc, app, ...
                    p.Results.markAlpha, p.Results.markSize, 'useTranslucentMark3d', p.Results.useTranslucentMark3d);
                TrialDataUtilities.Plotting.showFirstInLegend(h, as.alignDescriptor.markLabels{iMark});
            end
        end
        
        % used to annotate a time axis with the relevant start/stop/zero/marks
        % non-fixed marks as <markLabel> unless the range is less than a specified 
        % noise-threshold, in which case it is marked as though it were fixed
%         function drawTimeAxis(ad, varargin)
%             timeInfo = ad.timeInfo;
% 
%             % uses ad.labelInfo to call drawPrettyAxis
%             tLims = [];
%            % xLabel = ''; 
%             axh = [];
%             drawY = true; % also draw the y axis while we're here? otherwise they'll be nothing there
%             setXLim = false;
%             assignargs(varargin);
% 
%             if isempty(axh)
%                 axh = gca;
%             end
%             if isempty(tLims)
%                 if setXLim
%                     tLims = ad.getTimeAxisLims(timeInfo); %#ok<UNRCH>
%                 else
%                     tLims = xlim(axh);
%                 end
%             end
%             tMin = tLims(1);
%             tMax = tLims(2);
%               
%             labelInfo = ad.getLabelInfo(timeInfo, 'tMin', tMin, 'tMax', tMax);
%             tickPos = [labelInfo.time];
%             tickLabels = {labelInfo.name};
%             tickAlignments = {labelInfo.align};
%                      
%             if setXLim
%                 xlim([min(tickPos), max(tickPos)]);
%             end
%             
%             if drawY
%                 makePrettyAxis('yOnly', true); 
%             else
%                 axis(axh, 'off');
%                 box(axh, 'off');
%             end
%             
%             if all(~isnan(tLims))
%                 drawAxis(tickPos, 'tickLabels', tickLabels, 'tickAlignments', tickAlignments, 'axh', axh); 
%             end
%         end

    end
    

end
