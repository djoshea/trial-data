classdef AlignSummary
% this class stores aggregate statistics regarding event timing and is
% typically generated and stored within an AlignInfo instance. Its purpose
% is to store this information encapsulated from AlignInfo data.
% AlignSummary objects are generated by a pair of AlignDescriptor and
% ConditionDescriptor objects, because they generate a separate set of
% aggregate event occurrence statistics for each condition

    properties
        % AlignDescriptor object from which this was generated
        alignDescriptor
        
        % ConditionDescriptor object from which this was generated
        conditionDescriptor
    end
    
    properties(Dependent, SetAccess=protected)
        nConditions
        
        nMarks
        
        nIntervals
    end
    
    properties(SetAccess=protected)
        nTrials
        
        startMin
        startMax
        startMean
        
        stopMin
        stopMax
        stopMean
       
        % nMark x 1 cell array
        markMax
        markMin
        markMean
        
        % nInterval x 1 cell array 
        intervalStartMax
        intervalStartMin
        intervalStartMean
        
        % nInterval x 1 cell array 
        intervalStopMax
        intervalStopMin
        intervalStopMean
        
        % nConditions x 1 numeric array indicating how many trials
        % contribute to the statistics above (useful when aggregating)
        nTrialsByCondition
        
        % all times are relative to zero 
        % nConditions x 1 vector of earliest start times by condition
        startMinByCondition
        
        % nConditions x 1 vector of latest start times by condition
        startMaxByCondition
        
        % nConditions x 1 vector of mean start times by condition
        startMeanByCondition
        
        % nConditions x 1 vector of earliest stop times by condition
        stopMinByCondition
        
        % nConditions x 1 vector of earliest stop times by condition
        stopMaxByCondition
        
        % nConditions x 1 vector of mean stop times by condition
        stopMeanByCondition
        
        % nConditions x nMark cell array containing the
        % latest occurrence time(s) of that mark event (relative to the zero event)
        markMaxByCondition
        
        % nConditions x nMark cell array containing the
        % earliest occurrence time(s) of that mark event (relative to the zero event)
        markMinByCondition
        
        % nConditions x nMark cell array containing the
        % mean occurrence time(s) of that mark event (relative to the zero event)
        markMeanByCondition
        
        % nConditions x nInterval cell array containing the
        % latest occurrence time of the start of each occurrence of that interval 
        % (relative to the zero event)
        intervalStartMaxByCondition
       
        intervalStartMinByCondition
        
        intervalStartMeanByCondition
        
        intervalStopMaxByCondition
        
        intervalStopMinByCondition
        
        intervalStopMeanByCondition
    end
    
    methods
        function as = AlignSummary()
            
        end
    end
    
    methods
        function n = get.nConditions(as)
            n = numel(as.nTrialsByCondition);
        end
        
        function n = get.nMarks(as)
            n = numel(as.markMax);
        end
        
        function n = get.nIntervals(as)
            n = numel(as.intervalStartMax);
        end
    end
    
    methods(Static)
        % factory constructor method used by TDCA
        function as = buildFromConditionAlignInfo(conditionInfo, alignInfo)
            as = AlignSummary();
            as.alignDescriptor = AlignDescriptor.fromAlignDescriptor(alignInfo);
            as.conditionDescriptor = ConditionDescriptor.fromConditionDescriptor(conditionInfo);
            
            [startData, stopData] = alignInfo.getStartStopRelativeToZeroByTrial();
            markData = alignInfo.getAlignedMarkData();
            [intervalStartData, intervalStopData] = alignInfo.getAlignedIntervalData();
            
            % total number of valid trials contributing
            as.nTrials = nnz(alignInfo.valid);
            
             % compute summary statistics for all trials
            [as.startMin, as.startMax, as.startMean] = ...
                statsSingleEvent(startData);
            [as.stopMin, as.stopMax, as.stopMean] = ...
                statsSingleEvent(stopData);
            
            % compute summary statistics for EACH occurrence of EACH
            % mark and interval event.
            [as.markMin, as.markMax, as.markMean] = ...
                statsMultipleEvent(markData);
            [as.intervalStartMin, as.intervalStartMax, as.intervalStartMean] = ...
                statsMultipleEvent(intervalStartData);
            [as.intervalStopMin, as.intervalStopMax, as.intervalStopMean] = ...
                statsMultipleEvent(intervalStopData);
            
            % group the data by condition into a flattened nConditions x 1
            % array
            as.nTrialsByCondition = cellfun(@numel, conditionInfo.listByCondition(:));
            [startGrouped, stopGrouped, markGrouped, ...
                intervalStartGrouped, intervalStopGrouped] = ...
                conditionInfo.groupElementsFlattened(startData, stopData, markData, ...
                intervalStartData, intervalStopData);
 
            % compute summary statistics for each condition separately
            [as.startMinByCondition, as.startMaxByCondition, as.startMeanByCondition] = ...
                statsSingleEventByCondition(startGrouped);
            [as.stopMinByCondition, as.stopMaxByCondition, as.stopMeanByCondition] = ...
                statsSingleEventByCondition(stopGrouped);
            [as.markMinByCondition, as.markMaxByCondition, as.markMeanByCondition] = ...
                statsMultipleEventByCondition(markGrouped);
            [as.intervalStartMinByCondition, as.intervalStartMaxByCondition, as.intervalStartMeanByCondition] = ...
                statsMultipleEventByCondition(intervalStartGrouped);
            [as.intervalStopMinByCondition, as.intervalStopMaxByCondition, as.intervalStopMeanByCondition] = ...
                statsMultipleEventByCondition(intervalStopGrouped);
  
            function [mn, mx, avg] = statsSingleEvent(data)
                mn = nanmin(data);
                mx = nanmax(data);
                avg = nanmean(data);
            end
            
            % internal fn to compute the min and max and mean on a simple
            % cell of vectors (scalar events)
            function [mn, mx, avg] = statsSingleEventByCondition(dataCell)
                mn = cellfun(@nanmin, dataCell);
                mx = cellfun(@nanmax, dataCell);
                avg = cellfun(@nanmean, dataCell);
            end
                  
            % internal fn to compute the min, max, and mean of each event
            % in a cell of cell of vectors (i.e. multiple occurrence
            % events)
            function [mn, mx, avg] = statsMultipleEventByCondition(dataCellByCondition)
                [mn, mx, avg] = deal(cell(numel(dataCellByCondition), ...
                    size(dataCellByCondition{1}, 2)));
                
                for iC = 1:numel(dataCellByCondition)
                    [mn(iC, :), mx(iC, :), avg(iC, :)] = ...
                        statsMultipleEvent(dataCellByCondition{iC});
                end
            end
            
            function [mn, mx, avg] = statsMultipleEvent(dataCell)
                % dataCell is a nTrials x nDistinctEvents cell, 
                % which contains all event times for that
                % distinct event across the trials, the number of which
                % could potentially vary by trial. We comptue the min, max,
                % mean times of the 1st, 2nd, 3rd, ..., nth occurrence of
                % that event for all trials in the cell
                
                nOccurrences = cellfun(@numel, dataCell);
                
                % nDistinctEvents number of events to compute stats for
                maxOccurrencesByEvent = max(nOccurrences, [], 1);
                
                [mn, mx, avg] = deal(cell(size(dataCell, 2), 1));
                for iEv = 1:size(dataCell, 2)
                    padToLength = @(vec) [makerow(vec), ...
                        nan(1, maxOccurrencesByEvent(iEv)-numel(vec))];
                    % occurMat is nTrials x maxOccurrencesByEvent(iEv)
                    occurMat = cell2mat(cellfun(padToLength, dataCell(:, iEv), ...
                        'UniformOutput', false));
                    
                    mn{iEv} = nanmin(occurMat, [], 1)';
                    mx{iEv} = nanmax(occurMat, [], 1)';
                    avg{iEv} = nanmean(occurMat, 1)';
                end
            end
        end
        
        function as = buildByAggregation(alignSummarySet)
            % build a new AlignSummary object by aggregating over multiple
            % objects
            
            if iscell(alignSummarySet)
                set = makecol([alignSummarySet{:}]);
            else
                set = makecol(alignSummarySet);
            end
            
            as = AlignSummary();
            as.alignDescriptor = set(1).alignDescriptor;
            as.conditionDescriptor = set(1).conditionDescriptor;
            
            % TODO could check that all alignDescriptors and
            % conditionDescriptors are valid here, but would be slow
            
            aggNTrials = makecol([set.nTrials]); % used in nested functions below
            
            as.nTrials = sum(aggNTrials);
            
            [as.startMin, as.startMax, as.startMean] = ...
                aggregateSingleEventStats([set.startMin], [set.startMax], [set.startMean], aggNTrials);
            [as.stopMin, as.stopMax, as.stopMean] = ...
                aggregateSingleEventStats([set.stopMin], [set.stopMax], [set.stopMean], aggNTrials);
            
            % markMax is nMarks x 1, cat(2, set.markMax) is nMarks x nSummary
            [as.markMax, as.markMin, as.markMean] = aggregateMultipleEventStats(...
                cat(2, set.markMax), cat(2, set.markMin), ...
                cat(2, set.markMean), aggNTrials);
            
            [as.intervalStartMax, as.intervalStartMin, as.intervalStartMean] = aggregateMultipleEventStats(...
                cat(2, set.intervalStartMax), cat(2, set.intervalStartMin), ...
                cat(2, set.intervalStartMean), aggNTrials);
            
            [as.intervalStopMax, as.intervalStopMin, as.intervalStopMean] = aggregateMultipleEventStats(...
                cat(2, set.intervalStopMax), cat(2, set.intervalStopMin), ...
                cat(2, set.intervalStopMean), aggNTrials);
    
            % nConditions x nSummary matrix of trial counts
            nTrialsByConditionMat = cat(2, [set.nTrialsByCondition]);
            
            % args are nConditions x nSummary matrices
            [as.startMinByCondition, as.startMaxByCondition, as.startMeanByCondition] = ...
                aggregateSingleEventStatsByCondition(cat(2, set.startMinByCondition), ...
                cat(2, set.startMaxByCondition), cat(2, set.startMeanByCondition), ...
                nTrialsByConditionMat);
            
            [as.stopMinByCondition, as.stopMaxByCondition, as.stopMeanByCondition] = ...
                aggregateSingleEventStatsByCondition(cat(2, set.stopMinByCondition), ...
                cat(2, set.stopMaxByCondition), cat(2, set.stopMeanByCondition), ...
                nTrialsByConditionMat);
            
            % args are nConditions x nDistinctEvents (e.g. nMarks,
            % nIntervals) x nSummary
            [as.markMaxByCondition, as.markMinByCondition, as.markMeanByCondition] = ...
                aggregateMultipleEventStatsByCondition(cat(3, set.markMaxByCondition), ...
                cat(3, set.markMinByCondition), cat(3, set.markMeanByCondition), ...
                nTrialsByConditionMat);
            
            [as.intervalStartMaxByCondition, as.intervalStartMinByCondition, as.intervalStartMeanByCondition] = ...
                aggregateMultipleEventStatsByCondition(cat(3, set.intervalStartMaxByCondition), ...
                cat(3, set.intervalStartMinByCondition), cat(3, set.intervalStartMeanByCondition), ...
                nTrialsByConditionMat);
            
            [as.intervalStopMaxByCondition, as.intervalStopMinByCondition, as.intervalStopMeanByCondition] = ...
                aggregateMultipleEventStatsByCondition(cat(3, set.intervalStopMaxByCondition), ...
                cat(3, set.intervalStopMinByCondition), cat(3, set.intervalStopMeanByCondition), ...
                nTrialsByConditionMat);
            
            function [maxNew, minNew, meanNew] = aggregateSingleEventStats(...
                    maxData, minData, meanData, nTrialsData)
                minNew = nanmin(minData);
                maxNew = nanmax(maxData);
                meanNew = nansum(makecol(meanData) .* makecol(nTrialsData)) / sum(nTrialsData);
            end
            
            function [maxNew, minNew, meanNew] = aggregateSingleEventStatsByCondition(...
                    maxData, minData, meanData, nTrialsMat)
                [maxNew, minNew, meanNew] = deal(nanvec(size(maxData, 1)));
                for iC = 1:size(maxData, 1)
                    [maxNew(iC), minNew(iC), meanNew(iC)] = ...
                        aggregateSingleEventStats(maxData(iC, :), minData(iC, :), ...
                        meanData(iC, :), nTrialsMat(iC, :));
                end
            end
            
            function [maxNew, minNew, meanNew] = aggregateMultipleEventStats(...
                    maxData, minData, meanData, nTrialsData)
                % *Data and nOccurrences are nDistinctEvents x nSummary
                % cell matrices. nTrialsData is nSummary x 1 vector
                nDistinctEvents = size(maxData, 1);
                nOccurrences = cellfun(@numel, maxData);
                maxOccurrencesByEvent = max(nOccurrences, [], 2);
                
                [maxNew, minNew, meanNew] = deal(cell(nDistinctEvents, 1));
                
                for iEv = 1:nDistinctEvents
                    padToLength = @(vec) [makecol(vec); ...
                        nan(maxOccurrencesByEvent(iEv)-numel(vec), 1)];
                    % *Mat is maxOccurrencesByEvent x nSummary
                    maxMat = cell2mat(cellfun(padToLength, maxData(iEv, :), ...
                        'UniformOutput', false));
                    minMat = cell2mat(cellfun(padToLength, minData(iEv, :), ...
                        'UniformOutput', false));
                    meanMat = cell2mat(cellfun(padToLength, meanData(iEv, :), ...
                        'UniformOutput', false));
                    
                    % cell elements are maxOccurrencesByEvent x 1 vectors
                    maxNew{iEv} = nanmax(maxMat, [], 2);
                    minNew{iEv} = nanmin(minMat, [], 2);
                    meanNew{iEv} = nansum(bsxfun(@times, meanMat, makerow(nTrialsData))) / sum(nTrialsData);
                end
            end
            
            function [maxNew, minNew, meanNew] = aggregateMultipleEventStatsByCondition(...
                    maxData, minData, meanData, nTrialsData)
                % max/min/meanData are nConditions x nMarks x nSummary cell
                % arrays. *New are nConditions x nMarks cell arrays
                [maxNew, minNew, meanNew] = deal(cell(size(maxData, 1), size(maxData, 2)));
                for iC = 1:size(maxData, 1)
                    [maxNew(iC, :), minNew(iC, :), meanNew(iC, :)] = ...
                        aggregateMultipleEventStats(squeeze(maxData(iC, :, :)), squeeze(minData(iC, :, :)), ...
                            squeeze(meanData(iC, :, :)), nTrialsData(iC, :));
                end
            end
           
        end
       
       function ad = updateSummary(ad)
            % look over the timeInfo struct and compute aggregate statistics about
            % the timing of each event relative to .zero
            %
            % .summaryInfo(i) looks like
            %     .name 
            %     .median
            %     .mean
            %     .list
            return;
            
%             events = ad.getEventList(); 
% 
%             zeroTimes = [ad.timeInfo.(ad.zeroEvent)];
% 
%             for iEv = 1:length(events)
%                 event = events{iEv};
% 
%                 times = ad.timeInfo;
% 
%                 evi.fixed = true;
%                 evi.relativeMedian = ad.startOffset - ad.zeroOffset;
%                 evi.relativeList = repmat(ad.nTrials, 1, evi.relativeMedian); 
%                 evi.relativeMin = evi.relativeMedian;
%                 evi.relativeMax = evi.relativeMedian;
% 
%                 ad.startOffset - ad.zeroOffset;
%                 labelInfo(counter).name = ad.startLabel;
%                 labelInfo(counter).time = ad.startOffset - ad.zeroOffset;
%                 labelInfo(counter).align = 'left';
%                 labelInfo(counter).info = ad.startInfo;
%                 labelInfo(counter).markData = ad.startMarkData;
%                 labelInfo(counter).fixed = true;
%                 counter = counter + 1;
%                 drewStartLabel = true;
%             end
        end
    end

    methods % Labeling and axis drawing
        % struct with fields .time and and .name with where to label the time axis appropriately
        % pass along timeInfo so that the medians of non-fixed events can be labeled as well 
        function [labelInfo] = getLabelInfo(ad, varargin)
            % build a list of label names / times to mark on the time axis 
            % when using this alignment. Essentially, all events which are fixed relative
            % to zero (i.e. reference off the same event) will be included as labels
            % also, if 'tMin' and 'tMax' are specified, they will be drawn as well provided that 
            % the start and stop events aren't fixed relative to zero 
            
            timeInfo = ad.timeInfo;  %#ok<*PROP>
            
            % optionally provide time window which filters which labels will be included
            tMin = [];
            tMax = [];
            assignargs(varargin);

            labelInfo = struct('name', {}, 'time', {}, 'align', {}, 'info', {}, ...
                'markData', {}, 'fixed', {});
            counter = 1;

            drewStartLabel = false;

            % label the start event / min limit
            if ad.isStartFixedTime 
                if ~ad.isStartZero
                    % fixed but not redundant with zero
                    labelInfo(counter).name = ad.startLabel;
                    labelInfo(counter).time = ad.startOffset - ad.zeroOffset;
                    labelInfo(counter).align = 'left';
                    labelInfo(counter).info = ad.startInfo;
                    labelInfo(counter).markData = ad.startMarkData;
                    labelInfo(counter).fixed = true;
                    counter = counter + 1;
                    drewStartLabel = true;
                end
            else
                % label at minimum time
                labelInfo(counter).name = ad.startLabel;
                labelInfo(counter).time = min([timeInfo.start] - [timeInfo.zero]);
                labelInfo(counter).align = 'left';
                labelInfo(counter).info = ad.startInfo;
                labelInfo(counter).markData = ad.startMarkData;
                labelInfo(counter).fixed = true;
                counter = counter + 1;
                drewStartLabel = true;
            end
            
            % label the zero event provided that it lies within the start/stop window
            if ~ad.isZeroOutsideStartStop
                labelInfo(counter).name = ad.zeroLabel; 
                labelInfo(counter).time = 0;
                if drewStartLabel
                    labelInfo(counter).align = 'center';
                else
                    labelInfo(counter).align = 'left';
                end
                labelInfo(counter).info = ad.zeroInfo;
                labelInfo(counter).markData = ad.zeroMarkData;
                labelInfo(counter).fixed = true;
                counter = counter + 1;
            end

            % label the stop event / max limit
            if ad.isStopFixedTime
                if ~ad.isStopZero
                    % fixed but not redundant with zero
                    labelInfo(counter).name = ad.stopLabel; 
                    labelInfo(counter).time = ad.stopOffset - ad.zeroOffset;
                    labelInfo(counter).align = 'right';
                    labelInfo(counter).info = ad.stopInfo;
                    labelInfo(counter).markData = ad.stopMarkData;
                    labelInfo(counter).fixed = true;
                    counter = counter + 1;
                end
            else
                labelInfo(counter).name = ad.stopLabel; 
                labelInfo(counter).time = max([timeInfo.stop] - [timeInfo.zero]);
                labelInfo(counter).align = 'right';
                labelInfo(counter).info = ad.stopInfo;
                labelInfo(counter).markData = ad.stopMarkData;
                labelInfo(counter).fixed = true;
                counter = counter + 1;
            end

            % label each of the event marks that are fixed with respect to the zero event
            isMarkFixed = ad.isMarkFixedTime;
            for iMark = 1:length(ad.markEvents)
                if isMarkFixed(iMark)
                    % mark time is identical for each trial
                    labelInfo(counter).name = ad.markLabels{iMark};
                    labelInfo(counter).time = ad.markOffsets(iMark) - ad.zeroOffset;
                    labelInfo(counter).align = 'center';
                    labelInfo(counter).info = ad.markInfo{iMark};
                    labelInfo(counter).fixed = true;
                    labelInfo(counter).markData = ad.markMarkData(iMark);
                    counter = counter + 1;

                elseif ~isempty(timeInfo)
                    % compute the median time for this mark and put it down with <brackets>
                    % for now, mark only the first event occurrence
                    if iscell(timeInfo(1).mark)
                        markTimes = arrayfun(@(ti) ti.mark{iMark}(1) - ti.zero, ...
                            timeInfo([timeInfo.valid]), 'ErrorHandler', @(varargin) NaN);
                    else
                        markTimes = arrayfun(@(ti) ti.mark(iMark) - ti.zero, ...
                            timeInfo([timeInfo.valid]));
                    end
                    
                    medianMarkTime = nanmedian(markTimes);
                    minMarkTime = nanmin(markTimes);
                    maxMarkTime = nanmax(markTimes);

                    if abs(minMarkTime - medianMarkTime) <= ad.markRelativeDeltaIgnore && ...
                       abs(maxMarkTime - medianMarkTime) <= ad.markRelativeDeltaIgnore
                       % range acceptable, don't use < > brackets
                       fmat = '%s';
                       labelInfo(counter).fixed = true;
                    else
                       % mark median with < > brackets to indicate there is
                       % a range
                        if ad.markPlotMedians
                            fmat = '<%s>';
                            labelInfo(counter).fixed = false;
                        else
                            % not plotting medians, move to next mark
                            continue;
                        end
                    end
                    
                    labelInfo(counter).name = sprintf(fmat, ad.markLabels{iMark});
                    labelInfo(counter).time = medianMarkTime;
                    labelInfo(counter).align = 'center';
                    labelInfo(counter).markData = ad.markMarkData(iMark);
                    labelInfo(counter).info = ad.markInfo{iMark};
                    counter = counter + 1;
                end
            end
                 
            if ~isempty(tMin)
                % start not fixed, include one for the lower limit tMin
                % first check whether there is an existing label (from a
                % mark) at this point already...
                if ~any(floor([labelInfo.time]) == floor(tMin))
                    labelInfo(counter).name = ad.buildLabel(ad.zeroEvent, ad.zeroEventIndex, tMin);
                    labelInfo(counter).time = tMin;
                    labelInfo(counter).align = 'left';
                    labelInfo(counter).markData = false; % this is just convenience, don't mark on data
                    labelInfo(counter).fixed = true;
                    counter = counter + 1;
                    drewStartLabel = true; %#ok<NASGU>
                end
            end
                     
            if ~isempty(tMax)
                % stop not fixed, include one for the upper limit tMin
                % first check whether there is an existing label (from a
                % mark) at this point already...
                if ~any(floor([labelInfo.time]) == floor(tMax))
                    labelInfo(counter).name = ad.buildLabel(ad.zeroEvent, ad.zeroEventIndex, tMax);
                    labelInfo(counter).time = tMax;
                    labelInfo(counter).align = 'right';
                    labelInfo(counter).markData = false;
                    labelInfo(counter).fixed = true;
                    counter = counter + 1; %#ok<NASGU>
                end
            end

            % generate default label info where missing
            cmap = jet(length(labelInfo));
            for i = 1:length(labelInfo)
                default = struct('color', cmap(i, :), 'size', 10, 'marker', 'o');
                if isempty(labelInfo(i).info)
                    labelInfo(i).info = default;
                else
                    labelInfo(i).info = structMerge(default, labelInfo(i).info, 'warnOnOverwrite', false);
                end
            end
            
            times = [labelInfo.time];
            timeMask = true(size(times));
            if ~isempty(tMin)
                timeMask = timeMask & times >= tMin;
            end
            if ~isempty(tMax)
                timeMask = timeMask & times <= tMax;
            end
            labelInfo = labelInfo(timeMask);
            
            labelInfo = makecol(labelInfo);
        end
        
        function [info, valid] = getIntervalInfoByCondition(ad, ciOrig, varargin)
            % using the conditions picked out by ConditionInfo ci and the event info found in data
            % R, compute the start and stop times for each interval defined by this AlignDescriptor
            % 
            % info is a nConditions x 1 cell containing a struct with the data on each
            % of the intervals for that condition
            %
            % currently uses first trial from each condition's intervals,
            % but double checks that all trials have the same number of
            % start/stops within each interval
        
            timeInfo = ad.timeInfo;
            
            % TODO Implement condition matching
            valid = [timeInfo.valid];
            ci = ciOrig.markInvalid(~valid);
            
            nIntervals = size(ad.intervalEventsStart,1);
            info = struct();
             
            for iC = 1:ci.nConditions
                rMask = ci.listByCondition{iC};
                info(iC).interval = cell(nIntervals, 1);
                
                for iInt = 1:nIntervals
                    if isempty(rMask)
                        % no trials, fill with nan
                        info(iC).interval{iInt} = [NaN NaN];
                    else
                        % check that all trials within condition have the same number
                        % of periods for this interval
                        nPeriods = arrayfun(@(ti) size(ti.intervalStart{iInt}, 1), timeInfo(rMask));
                        if length(unique(nPeriods)) > 1
                            debug('WARNING: Trials within condition have differing number of periods for interval %d\n', iInt);
                        end

                        % grab the interval info from the first trial
                        info(iC).intervalStart{iInt} = timeInfo(rMask(1)).intervalStart{iInt} - timeInfo(rMask(1)).zero;
                        info(iC).intervalStop{iInt} = timeInfo(rMask(1)).intervalStop{iInt} - timeInfo(rMask(1)).zero;
                        
                    end
                end
            end
        end
        
        % used to annotate a time axis with the relevant start/stop/zero/marks
        % non-fixed marks as <markLabel> unless the range is less than a specified 
        % noise-threshold, in which case it is marked as though it were fixed
        function drawTimeAxis(ad, varargin)
            timeInfo = ad.timeInfo;

            % uses ad.labelInfo to call drawPrettyAxis
            tLims = [];
           % xLabel = ''; 
            axh = [];
            drawY = true; % also draw the y axis while we're here? otherwise they'll be nothing there
            setXLim = false;
            assignargs(varargin);

            if isempty(axh)
                axh = gca;
            end
            if isempty(tLims)
                if setXLim
                    tLims = ad.getTimeAxisLims(timeInfo); %#ok<UNRCH>
                else
                    tLims = xlim(axh);
                end
            end
            tMin = tLims(1);
            tMax = tLims(2);
              
            labelInfo = ad.getLabelInfo(timeInfo, 'tMin', tMin, 'tMax', tMax);
            tickPos = [labelInfo.time];
            tickLabels = {labelInfo.name};
            tickAlignments = {labelInfo.align};
                     
            if setXLim
                xlim([min(tickPos), max(tickPos)]);
            end
            
            if drawY
                makePrettyAxis('yOnly', true); 
            else
                axis(axh, 'off');
                box(axh, 'off');
            end
            
            if all(~isnan(tLims))
                drawAxis(tickPos, 'tickLabels', tickLabels, 'tickAlignments', tickAlignments, 'axh', axh); 
            end
        end

        % annotate data time-series with markers according to the labels indicated
        % by this align descriptor
        %
        % N is the number of traces to be annotated
        % T is number of time points
        % D is data dimensionality e.g. 1 or 2 or 3)
        %
        % the sizes of timeInfo and data may be one of the following:
        %   one-trial per data trace:
        %     timeInfo is N x 1 struct vec
        %     timeData is N x T matrix or N x 1 cell of T_i vectors
        %     data is N x T x D matrix or N x 1 cell of T_i x D matrices
        %
        %   many-trials per data trace:
        %     timeInfo is N x 1 cell array of ? x 1 struct vecs 
        %     timeData is N x T matrix or N x 1 cell of T_i vectors
        %     data is N x T x D matrix or N x 1 cell of T_i x D matrices 
        %     for this, the median will be computed for each data trace in timeInfo{:} and plotted accordingly
        %     on each of the N groups of timeInfos on data(m, :, :)
        %
        function drawOnData(ad, timeData, data, varargin)
            p = inputParser();
            p.addParamValue('drawLegend', false, @islogical);
            p.parse(varargin{:});
            
            timeInfo = ad.timeInfo;

            hold on

            N = length(timeInfo);
            assert(isvector(timeInfo) && (isstruct(timeInfo) || iscell(timeInfo)), ...
                'timeInfo must be struct vector or cell vector');
            assert(iscell(data) || N == size(data, 1), 'Length of timeInfo must match size(data, 1)');
            assert(~iscell(data) || (isvector(data) && N == length(data)), 'Data length must match timeInfo');
            assert(iscell(timeData) || N == size(timeData, 1), 'Length of timeInfo must match size(timeData, 1)');
            assert(~iscell(timeData) || (isvector(timeData) && N == length(timeData)), 'TimeData length must match timeInfo');
            assert(iscell(timeData) == iscell(data), 'TimeData and Data must both be cells or both matrices');

            hleg = nan(size(timeInfo));
            legstr = cell(size(timeInfo));
            for i = 1:length(timeInfo)
                if iscell(timeInfo)
                    % each time info is for a single data
                    ti = timeInfo{i};
                else
                    ti = timeInfo(i);
                end
                labelInfo = ad.getLabelInfo(ti);
                
                if iscell(data)
                    tvec = timeData{i};
                    dmat = data{i};
                else
                    tvec = squeeze(timeData(i, :));
                    dmat = squeeze(data(i, :, :));
                end
                
                if ~isempty(dmat)
                    drawOnSingle(ti, tvec, dmat, labelInfo);
                end
            end
            
            if p.Results.drawLegend
                idx = 1;
                for iLabel = 1:length(labelInfo)
                    info = labelInfo(iLabel).info;
                    if ~labelInfo(iLabel).markData
                        continue;
                    end
                    hleg(idx) = plot(NaN, NaN, info.marker, 'MarkerFaceColor', info.color, ...
                        'MarkerEdgeColor', info.color, 'MarkerSize', info.size);
                    legstr{idx} = labelInfo(iLabel).name;
                    idx = idx + 1;
                end
                
                legend(hleg, legstr, 'Location', 'NorthEast');
                legend boxoff;
            end
            
            function drawOnSingle(timeInfo, timeVec, dmat, labelInfo)
                % timeInfo is a struct array or single struct
                % dmat is T x D matrix
                nDim = size(dmat, 2);

                for iLabel = 1:length(labelInfo)
                    if ~labelInfo(iLabel).markData
                        continue;
                    end
                    info = labelInfo(iLabel).info;
                    ind = find(floor(labelInfo(iLabel).time) == floor(timeVec), 1);
                    if isempty(ind), continue, end
                    dvec = dmat(ind, :);
                    extraArgs = {info.marker, 'MarkerFaceColor', info.color, ...
                            'MarkerEdgeColor', info.color, 'MarkerSize', info.size};
                    if nDim == 1
                        plot(timeVec(ind), dvec(1), extraArgs{:});
                    elseif nDim == 2
                        plot(dvec(1), dvec(2), extraArgs{:});
                    elseif nDim == 3
                        plot3(dvec(1), dvec(2), dvec(3), extraArgs{:});
                    end
                end
                labelInfo = struct('name', {}, 'time', {}, 'align', {}, 'info', {}, ...
                    'markOndmat', {}, 'fixed', {});
            end
        end
    end

end
