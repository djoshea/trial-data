classdef ConditionDescriptor 
% ConditionDescriptor is a static representation of a A-dimensional combinatorial
% list of attribute values

    % the following properties are computed dynamically on the fly as they
    % are easy to compute
    properties(Dependent, Transient)
        nAttributes % how many attributes: ndims(values)
        nValuesByAttribute % how many values per attribute: size(values)
        
        nAxes % how many dimensions of grouping axe
        nValuesAlongAxes % X x 1 array of number of elements along the ax`is
        
        nConditions % how many total conditions
        conditionsSize
        
        allAxisValueListsManual
        allAttributeValueListsManual
        allValueListsManual % true if all attribute lists and axis lists are manually (not automatically determined)
    end
        
    % the following properties are computed dynamically on the fly as they
    % are easy to compute
    properties(Dependent, Transient)
        attributeDescriptions
        attributeAlongWhichAxis % A x 1 array indicating which axis an attribute contributes to (or NaN)
        attributeValueModes % A x 1 array of AttributeValue* constants above
        attributeActsAsFilter % A x 1 logical array : does this attribute have a
                % value list or manual bin setup that would invalidate trials?
        
        axisNames % strcell with a short name for each axis
        axisDescriptions % strcell describing each axis

        axisValueListModesAsStrings
        axisRandomizeModesAsStrings
        
        conditionsAsLinearInds % linear index corresponding to each condition if flattened 
    end

    properties
        description = '';
        
        % updates cache on set
        
        % function which maps .values(i) struct --> name of condition i
        % called as nameFn(conditionInfo, 'multiline', tf) where
        % multiline=true means use \n to separate lines when appropriate
        nameFn 
        
        % updates cache on set
        appearanceFn; % function which takes struct('attrName1', attrVal1, 'attrName2', attrVal2)
                      % and returns struct('color', 'k', 'lineWidth', 2, ...); 
    end
     
    properties(SetAccess=protected)
        % modifications to appearances generated by appearanceFn,
        appearanceColorByAttributesList
        appearanceColorByAttributesCmap
        
        appearanceColorByAxesList
        appearanceColorByAxesCmap
        
        % A x 1 : by attribute                       
        attributeNames = {}; % A x 1 cell array : list of attributes for each dimension
        attributeRequestAs = {}; % A x 1 cell array : list of names by which each attribute should be requested corresponding to attributeNames
        
        axisAttributes % G x 1 cell : each is cellstr of attributes utilized along that grouping axis
    
        attributeSortByList = {}; % cellstr of attribute names (or '-attribute') specifying how to sort trials within each condition list
    end
    
    properties(SetAccess=protected, Hidden)
        attributeNumeric = []; % A x 1 logical array : is this attribute a numeric value? 
        attributeValueListsManual = {}; % A x 1 cell array of permitted values (or cells of values) for this attribute
        attributeValueBinsManual = {}; % A x 1 cell array of value Nbins x 2 value bins to use for numeric lists
        attributeValueBinsAutoCount % A x 1 numeric array of Nbins to use when auto computing the bins, NaN if not in use
        attributeValueBinsAutoModes % A x 1 numeric array of either AttributeValueBinsAutoUniform or AttributeValueBinsAutoQuantiles
        
        axisValueListsManual % G x 1 cell of cells: each contains a struct specifying an attribute specification for each element along the axis
        axisValueListsOccupiedOnly % G x 1 logical indicating whether to constrain the combinatorial valueList to only occupied elements (with > 0 trials)

        axisRandomizeModes % G x 1 numeric of constants beginning with Axis* (see below)
        axisRandomizeWithReplacement % G x 1 logical indicating whether ot not to use replacement
        axisRandomizeResampleFromList % G x 1 cell of cells: one for each axis
            % for each axis, a cell whose length matches the number of
            % values for that axis, specifying which positions to draw
            % conditions from for that position
            %
            % e.g. if axis..List{1} contained {2 2}, we would be sampling along axis 1
            % from trials with valueList{2} to fill conditions at subscript 1 and 2
            %
            % e.g. if axis..List{1} contained {1 2 3}, we would be doing
            % the equivalent of axisResampleFromSame along axis 1
            
        isResampledWithinConditions = false; % boolean flag indicating whether to resampleFromSame the listByCondition
                      % after building it, which resamples with replacement
                      % without changing condition labels.

        randomSeed = 0;
        
        % scalar numeric seed initializing the RandStream which will generate shuffling or resampling along each axis
        % the persistence of this seed ensures that the randomization can reliably be repeated, but the results may change if anything
        % about any of the attributes / axes is changed.
    end
    
    % END OF STORED TO DISK PROPERTIES
    
    properties(Hidden, Access=protected)
        odc % handle to a ConditionDescriptorOnDemandCache
    end
    
    % THE FOLLOWING PROPERTIES WRAP EQUIVALENT PROPERTIES IN ODC
    % on get: retrieve from odc, if empty {call build<Property>, store in odc, return it}
    % on set: make copy of odc to alleviate dependency, store in odc
    % 
    % Note: we use the build<Property> methods because property getters
    % cannot be inherited, so subclasses can override the build method
    % instead.
    properties(Transient, Dependent, SetAccess=protected)        
        % These are generated on the fly by property get, but cached for speed, see invalidateCache to reset them 
        
        % these are X-dimensional objects where X is nAxes
        conditions % X-dimensional struct where values(...idx...).attribute is the value of that attribute on that condition
        conditionsAxisAttributesOnly % includes only the attributes actively selected for
        conditionsAsStrings % includes attribute values as strings rather than numeric 
        conditionsAsStringsIncludingFilters
        
        appearances % A-dimensional struct of appearance values
        names % A-dimensional cellstr array with names of each condition 
        namesShort 
        namesMultiline % A-dimension cellstr array with names of each condition separated into multiple lines via \n
        
        attributeValueLists % A x 1 cell array of values allowed for this attribute
                           % here just computed from attributeValueListManual, but in ConditionInfo
                           % can be automatically computed from the data
        attributeValueListsAsStrings % same as above, but everything is a string
        
        axisValueLists % G dimensional cell array of structs which select attribute values for that position along an axis
        axisValueListsAsStrings % G dimensional cell array of cellstr which give names for the values along each axis (including attribute name)
        axisValueListsAsStringsShort % G dimensional cell array of cellstr which give shortened names for the values along each axis (just values)
        axisValueListModes % G dimensional array of AxisValueList* constants below indicating how axis value lists are generated
    end
    
    % how are attribute values determined for a given attribute?
    properties(Constant, Hidden)
        % for attributeValueListModes
        AttributeValueListManual = 1;
        AttributeValueListAuto = 2;
        AttributeValueBinsManual = 3;
        AttributeValueBinsAutoUniform = 4;
        AttributeValueBinsAutoQuantiles = 5;
        
        % for axisRandomizeModes
        AxisOriginal = 1; % use original axis ordering
        AxisShuffled = 2; % shuffle the labels along this axis preserving the original counts within each bin
        AxisResampledFromSpecified = 3; % resample with replacement from a different bin (see axisRandomizeResampleFromList)
        
        % for axisValueListModes
        AxisValueListAutoAll = 1;
        AxisValueListAutoOccupied = 2;
        AxisValueListManual = 3;
    end
    
    % Constructor, load, save methods
    methods
        function ci = ConditionDescriptor()
            ci.odc = ConditionDescriptorOnDemandCache();
        end
    end

    methods % General methods, setters and getters
        
        % flush the contents of odc as they are invalid
        % call this at the end of any methods which would want to
        % regenerate these values
        function ci = invalidateCache(ci)
            ci.warnIfNoArgOut(nargout);

            % here we precompute these things to save time, 
            % but each of these things also has a get method that will
            % recompute this for us
            if ~isempty(ci.odc)
                ci.odc  = ci.odc.copy();
                ci.odc.flush();
            end
        end
        
        function ci = invalidateAppearanceInfo(ci)
            ci.warnIfNoArgOut(nargout);
            
            if ~isempty(ci.odc)
                ci.odc  = ci.odc.copy();
                ci.odc.flushAppearanceInfo();
            end
        end

        function ci = set.nameFn(ci, fn)
            ci.nameFn = fn;
            ci = ci.invalidateCache();
        end

        function ci = set.appearanceFn(ci, fn)
            ci.appearanceFn = fn;
            ci = ci.clearAppearanceModifications();
            % only need to flush appearance info to save time
            ci = ci.invalidateAppearanceInfo();
        end
        
        function ci = freezeAppearances(ci)
            % cache the current condition appearances
            
            frozenConditions = ci.conditionsAxisAttributesOnly;
            frozenAppearances = ci.appearances;
            ci.appearanceFn = @frozenAppearanceLookup;
            
            function a = frozenAppearanceLookup(ci, varargin)
                a = repmat(AppearanceSpec(), ci.conditionsSize);
                [cFrozen, cNew] = matchFields(frozenConditions, ci.conditions);
                if numel(fieldnames(cFrozen)) == 0
                    warning('No attributes in common with frozen condition appearances');
                    return;
                end
                
                nDuplicate = 0;
                nMissing = 0;
                for i = 1:numel(a)
                    mask = arrayfun(@(frozen) isequal(cNew(i), frozen), cFrozen);
                    if nnz(mask) == 0
                        nMissing = nMissing + 1;
                        continue;
                    elseif nnz(mask) > 1
                        nDuplicate = nDuplicate + 1;
                    end
                    
                    a(i) = frozenAppearances(find(mask, 1));
                end
                      
                if nMissing > 0
                    warning('Unable to find frozen AppearanceSpec for %d conditions', nMissing);
                end
                if nDuplicate > 0
                    warning('Encountered multiple frozen AppearanceSpecs for %d conditions', nDuplicate);
                end
            end
             
            function [m1, m2] = matchFields(s1, s2)
                f1 = fieldnames(s1);
                f2 = fieldnames(s2);
                m1 = rmfield(s1, setdiff(f1, f2));
                m2 = rmfield(s2, setdiff(f2, f1));
                m2 = orderfields(m2, m1);
            end
        end
        
        function printDescription(ci) 
            tcprintf('yellow', '%s:\n', class(ci));
            tcprintf('inline', '  {bright blue}Attributes:\n');
            attrDesc = ci.generateAttributeDescriptions(true);
            for i = 1:ci.nAttributes
                tcprintf('inline', '    %s: {white}%s\n', attrDesc{i}, ...
                    tcprintfEscape(strjoin(ci.attributeValueListsAsStrings{i}, ', ')));
            end
            axisDesc = ci.generateAxisDescriptions(true);
            tcprintf('inline', '  {bright blue}Axes:\n');
            for i = 1:ci.nAxes
                tcprintf('inline', '    %s: {white}%s\n', axisDesc{i}, ...
                    tcprintfEscape(strjoin(ci.axisValueListsAsStrings{i}, ', ')));
            end
            
            nRandom = nnz(ci.axisRandomizeModes ~= ci.AxisOriginal);
            if nRandom > 0
                if nRandom == 1
                    s = 'axis';
                else
                    s = 'axes';
                end
                tcprintf('inline', '  {bright red}%d %s with randomization applied\n', nRandom, s);
            end
            
            if ~isempty(ci.attributeSortByList)
                tcprintf('inline', '  {bright blue}Sort: {purple}%s\n', strjoin(ci.attributeSortByList, ', '));
            end
            if ci.isResampledWithinConditions
                tcprintf('inline', '  {bright red}Trials resampled within conditions\n');
            end
            
        end
        
        function printOneLineDescription(ci)           
            if ci.nAxes == 0
                axisStr = 'no grouping axes';
            else
                axisStr = strjoin(ci.axisDescriptions, ' , ');
            end
            
            attrFilter = ci.attributeNames(ci.attributeActsAsFilter);
            if isempty(attrFilter)
                filterStr = 'no filtering';
            else
                filterStr = sprintf('filtering by %s', strjoin(attrFilter));
            end
            
            tcprintf('inline', '{yellow}%s: {none}%s, %s\n', ...
                class(ci), axisStr, filterStr);
        end

        function disp(ci)
            ci.printDescription();
            fprintf('\n');
            builtin('disp', ci);
        end
        
        function tf = get.allAxisValueListsManual(ci)
            % returns true if all axis value
            % lists are manually specified, false otherwise if anything is
            % automatically determined
            
            tf = all(ci.axisValueListModes == ci.AxisValueListManual);
        end
        
        function tf = get.allAttributeValueListsManual(ci)
            % returns true if all attribute value lists 
            % are manually specified, false otherwise if anything is
            % automatically determined
            
            tf = all(ismember(ci.attributeValueModes, [ci.AttributeValueListManual, ci.AttributeValueBinsManual]));
        end
        
        function tf = get.allValueListsManual(ci)
            % returns true if all attribute value lists and axis value
            % lists are manually specified, false otherwise if anything is
            % automatically determined
            tf = ci.allAxisValueListsManual && ci.allAttributeValueListsManual;
        end
    end

    methods % Axis related 
        function n = get.nAxes(ci)
            n = numel(ci.axisAttributes);
        end
        
        function a = get.attributeAlongWhichAxis(ci)
            a = nanvec(ci.nAttributes);
            for iX = 1:ci.nAxes
                a(ci.getAttributeIdx(ci.axisAttributes{iX})) = iX;
            end
        end
        
        function modes = get.axisValueListModes(ci)
            modes = nanvec(ci.nAxes);
            
            for iX = 1:ci.nAxes
                if ~isempty(ci.axisValueListsManual{iX})
                    modes(iX) = ci.AxisValueListManual;
                elseif ci.axisValueListsOccupiedOnly(iX)
                    modes(iX) = ci.AxisValueListAutoOccupied;
                else
                    modes(iX) = ci.AxisValueListAutoAll;
                end
            end
        end

        function counts = get.nValuesAlongAxes(ci)
            counts = cellfun(@numel, ci.axisValueLists); 
        end
        
        % determine whether each attribute acts to filter valid trials
        function tf = get.attributeActsAsFilter(ci)
            modes = ci.attributeValueModes;
            tf = ismember(modes, [ci.AttributeValueListManual, ci.AttributeValueBinsManual]);
        end
        
        function names = get.axisNames(ci)
            names = cellvec(ci.nAxes);            
            for iX = 1:ci.nAxes
                attr = ci.axisAttributes{iX};
                names{iX} = strjoin(attr, ' x ');
            end
        end
        
        function desc = get.axisDescriptions(ci)
            desc = ci.generateAxisDescriptions();
        end
        
        function desc = generateAxisDescriptions(ci, useColor)
            if nargin < 2
                useColor = false;
            end
            desc = cellvec(ci.nAxes);
            
            vlStrCell = ci.axisValueListModesAsStrings;
            randStrCell = ci.axisRandomizeModesAsStrings;
            for iX = 1:ci.nAxes
                attr = ci.axisAttributes{iX};
                nv = ci.conditionsSize(iX);
                vlStr = vlStrCell{iX};
                randStr = randStrCell{iX}; 
                if ~isempty(vlStr)
                    vlStr = [' ' vlStr]; %#ok<AGROW>
                end
                if ~isempty(randStr)
                    randStr = [' ' randStr]; %#ok<AGROW>
                end
                if useColor
                    desc{iX} = sprintf('{purple}%s {darkGray}(%d%s%s)', ...
                        strjoin(attr, ' x '), nv, vlStr, randStr);
                else
                    desc{iX} = sprintf('%s (%d%s%s)', ...
                        strjoin(attr, ' x '), nv, vlStr, randStr);
                end
            end
        end
        
        function strCell = get.axisValueListModesAsStrings(ci)
            strCell = cellvec(ci.nAxes);
            for iX = 1:ci.nAxes
                switch ci.axisValueListModes(iX)
                    case ci.AxisValueListAutoAll
                        vlStr = 'auto';
                    case ci.AxisValueListAutoOccupied
                        vlStr = 'autoOccupied';
                    case ci.AxisValueListManual
                        vlStr = 'manual';
                    otherwise
                        error('Unknown axisValueListMode for axis %d', iX);
                end
                strCell{iX} = vlStr;
            end
        end

        function strCell = get.axisRandomizeModesAsStrings(ci)
            strCell = cellvec(ci.nAxes);
            for iX = 1:ci.nAxes
                if ci.axisRandomizeWithReplacement(iX)
                    replaceStr = 'WithReplacement';
                else
                    replaceStr = '';
                end
                switch ci.axisRandomizeModes(iX)
                    case ci.AxisOriginal
                        randStr = '';
                    case ci.AxisShuffled
                        randStr = ['shuffled' replaceStr];
                    case ci.AxisResampledFromSpecified
                        randStr = ['resampled' replaceStr];
                    otherwise
                        error('Unknown axisRandomizeMode for axis %d', iX);
                end
                strCell{iX} = randStr;
            end
        end

        function ci = addAxis(ci, varargin)
            ci.warnIfNoArgOut(nargout);

            p = inputParser;
            p.addOptional('attributes', {}, @(x) ischar(x) || iscellstr(x));
            p.addParameter('name', '', @ischar);
            p.addParameter('valueList', {}, @(x) true);
            p.parse(varargin{:});

            if ~iscell(p.Results.attributes)
                attr = {p.Results.attributes};
            else
                attr = p.Results.attributes;
            end
            ci.assertHasAttribute(attr);
            
            ci = ci.removeAttributesFromAxes(attr);

            % create a grouping axis
            idx = ci.nAxes + 1; 
            ci.axisAttributes{idx} = makecol(attr);
            ci.axisAttributes = makecol(ci.axisAttributes);
            ci.axisValueListsManual{idx} = p.Results.valueList;
            ci.axisRandomizeModes(idx) = ci.AxisOriginal;
            ci.axisRandomizeWithReplacement(idx) = false;
            ci.axisRandomizeResampleFromList{idx} = [];
            
            ci.axisValueListsOccupiedOnly(idx) = true;

            ci = ci.invalidateCache();
        end
        
        function ci = maskAxes(ci, mask)
            ci.warnIfNoArgOut(nargout);
            
            ci.axisAttributes = makecol(ci.axisAttributes(mask));
            ci.axisValueListsManual = ci.axisValueListsManual(mask);
            ci.axisRandomizeModes = ci.axisRandomizeModes(mask);
            ci.axisRandomizeWithReplacement = ci.axisRandomizeWithReplacement(mask);
            ci.axisRandomizeResampleFromList = ci.axisRandomizeResampleFromList(mask);
            ci.axisValueListsOccupiedOnly = ci.axisValueListsOccupiedOnly(mask);
            
            ci = ci.invalidateCache();
        end

        % wipe out existing axes and creates simple auto axes along each 
        function ci = groupBy(ci, varargin)
            ci.warnIfNoArgOut(nargout);
            ci = ci.clearAxes();
            
            for i = 1:numel(varargin)
                ci = ci.addAxis(varargin{i});
            end
        end

        function ci = groupByAll(ci)
            ci.warnIfNoArgOut(nargout);
            ci = ci.groupBy(ci.attributeNames{:});
        end

        % remove all axes
        function ci = clearAxes(ci)
            ci.warnIfNoArgOut(nargout);

            ci = ci.maskAxes([]);

            ci = ci.invalidateCache();
        end
        
        function ci = removeAttributesFromAxes(ci, namesOrIdx)
            ci.warnIfNoArgOut(nargout);
            attrIdx = ci.getAttributeIdx(namesOrIdx);
            attrNames = ci.attributeNames(attrIdx);
            
            if ci.nAxes == 0
                return;
            end
            
            whichAxis = ci.attributeAlongWhichAxis;
            removeAxisMask = falsevec(ci.nAxes);
            for iAI = 1:numel(attrIdx)
                iA = attrIdx(iAI);
                iX = whichAxis(iA);
                if isnan(iX)
                    continue;
                end
                
                % remove this attribute from axis iX
                if ci.axisRandomizeModes(iX) ~= ci.AxisOriginal
                    error('Cowardly refusing to remove attributes from axis with randomization applied');
                end
                if ci.axisValueListModes(iX) == ci.AxisValueListManual
                    error('Cowardly refusing to remove attributes from axis with manual value list specified');
                end
                
                maskInAxis = strcmp(ci.axisAttributes{iX}, attrNames{iAI});
                if all(maskInAxis)
                    removeAxisMask(iX) = true;
                else
                    ci.axisAttributes{iX} = makecol(ci.axisAttributes{iX}(~maskInAxis));
                    % clear out manual value list as it's likely invalid now
                    ci.axisValueListsManual{iX} = [];
                    % and reset the randomization
                    ci.axisRandomizeModes(iX) = ci.AxisOriginal;
                end
            end
            
            ci = ci.maskAxes(~removeAxisMask);
        end
        
        function ci = setAxisValueList(ci, axisSpec, valueList)
            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(axisSpec);
                
            if(numel(idx) == 1 && numel(ci.axisAttributes{idx}) == 1 && iscell(valueList) && ~isstruct(valueList{1}))
                % for one axis with single attribute, valueList can simply be a cell
                % array of values
                %debug('Auto converting value list for single attribute axis\n');
                valueCell = valueList;
                if ~iscell(valueCell), valueCell = num2cell(valueCell); end;
                valueList = struct(ci.axisAttributes{idx}{1}, valueCell);
            end  
            
            assert(isstruct(valueList) && isvector(valueList), ....
                'Value list must be a struct vector');
            assert(isempty(setxor(fieldnames(valueList), ci.axisAttributes{idx})), ...
                'Value list fields must match axis attributes');
            ci.axisValueListsManual{idx} = valueList;
            
            ci = ci.invalidateCache();
        end
        
        function valueList = getAxisValueList(ci, axisSpec)
            idx = ci.axisLookupByAttributes(axisSpec);
            valueList = makecol(ci.axisValueLists{idx});
        end
        
        function ci = setAxisValueListAutoAll(ci, axisSpec)
            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(axisSpec);
            
            ci.axisValueListsManual(idx) = {[]};
            ci.axisValueListsOccupiedOnly(idx) = false;
            ci = ci.invalidateCache();
        end
        
        function ci = setAxisValueListAutoOccupied(ci, axisSpec)
            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(axisSpec);
            
            [ci.axisValueListsManual{idx}]= deal({});
            ci.axisValueListsOccupiedOnly(idx) = true;
            
            ci = ci.invalidateCache();
        end
        
        function nv = get.conditionsSize(ci)
            nv = TensorUtils.expandSizeToNDims(size(ci.conditions), ci.nAxes);
        end

        function linearInds = get.conditionsAsLinearInds(ci)
            linearInds = TensorUtils.containingLinearInds(ci.conditionsSize);
        end

        function n = get.nConditions(ci)
            n = prod(ci.conditionsSize);
        end

        % lookup axis idx by attribute char or cellstr, or cell of attribute cellstr
        % if a numeric indices are passed in, returns them through.
        % if not found, throws an error
        % useful for accepting either axis idx or attributes in methods
        function idx = axisLookupByAttributes(ci, attr)
            if isnumeric(attr)
                assert(all(attr >= 1 & attr <= ci.nAxes), 'Axis index out of range');
                idx = attr;
                return;
            end

            if ischar(attr)
                attr = {attr};
            end
            if iscellstr(attr)
                attr = {attr};
            end
            for iAttr = 1:numel(attr)
                if ~iscell(attr{iAttr})
                    attr{iAttr} = attr(iAttr);
                end
            end
            
            % attr is a cell of cellstr of attributes, and axisAttributes is a cell
            % of such cellstr (the attributes along each axis).
            % Consequently, we're looking for an EXACT match between attr
            % and an axis
            idx = nanvec(numel(attr));
            for iAttr = 1:numel(attr)
                for i = 1:ci.nAxes
                    if isempty(setxor(attr{iAttr}, ci.axisAttributes{i}))
                        idx(iAttr) = i;
                        break;
                    end
                end
                
                assert(~isnan(idx(iAttr)), 'Axis with attributes %s not found', ...
                    strjoin(attr{iAttr}, ' x '));
            end
            
        end
    end

    methods % Axis randomization related
        function ci = setRandomSeed(ci, seed)
            ci.warnIfNoArgOut(nargout);
            ci.randomSeed = seed; 
        end
        
        function ci = newRandomSeed(ci)
            ci.warnIfNoArgOut(nargout);
            ci = ci.setRandomSeed(RandStream.shuffleSeed());
        end
        
        function ci = newRandomSeedIfEmpty(ci)
            ci.warnIfNoArgOut(nargout);
            if isempty(ci.randomSeed)
                warning('Automatically selecting random seed. Call .setRandomSeed(seed) for deterministic resuls');
                ci = ci.newRandomSeed();
            end
        end
        
        function seedRandStream(ci, seed)
            if nargin < 2
                seed = ci.randomSeed;
            end
                
            s = RandStream('mt19937ar', 'Seed', seed);
            RandStream.setGlobalStream(s);
        end
        
        function ci = noRandomization(ci)
            ci.warnIfNoArgOut(nargout);
            ci.isResampledWithinConditions = false;
            for i = 1:ci.nAxes
                ci = ci.axisNoRandomization(i);
            end
        end  
        
        function ci = resampleTrialsWithinConditions(ci)
            ci.warnIfNoArgOut(nargout);
            ci = ci.newRandomSeedIfEmpty();
            ci.isResampledWithinConditions = true;
            ci = ci.invalidateCache();
        end
        
        function ci = axisNoRandomization(ci, idxOrAttr)
            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(idxOrAttr);
            ci.axisRandomizeModes(idx) = ci.AxisOriginal;
            ci.axisRandomizeResampleFromList{idx} = [];
            ci.axisRandomizeWithReplacement(idx) = false;
            ci = ci.invalidateCache();
        end
                   
        function ci = axisShuffle(ci, idxOrAttr, replace) 
            ci.warnIfNoArgOut(nargout);
            if nargin < 3
                replace = false;
            end
            
            ci = ci.newRandomSeedIfEmpty();
            idx = ci.axisLookupByAttributes(idxOrAttr);
            ci.axisRandomizeModes(idx) = ci.AxisShuffled;
            ci.axisRandomizeResampleFromList{idx} = [];
            ci.axisRandomizeWithReplacement(idx) = replace;
            ci = ci.invalidateCache();
        end

        function ci = axisResampleFromSpecifiedValueListIndices(ci, axisIdxOrAttr, resampleFromList, replace) 
            ci.warnIfNoArgOut(nargout);
            if nargin < 4
                replace = false;
            end
            ci = ci.newRandomSeedIfEmpty();
            idx = ci.axisLookupByAttributes(axisIdxOrAttr);
            assert(isscalar(idx), 'Method operates on only one axis');

            nValues = ci.nValuesAlongAxes(idx);
            if isscalar(resampleFromList)
                % all resampling from same, clone to length of axis
                resampleFromList = repmat(resampleFromList, nValues, 1);
            end
            
            assert(numel(resampleFromList) == nValues, 'Resample from list must match number of values along axis');
            
            if ~iscell(resampleFromList)
                % convert to cell array
                resampleFromList = num2cell(resampleFromList);
            end
            
            % replace each list of numeric indices with struct match
            % templates
            axisValueList = ci.axisValueLists{idx};
            for i = 1:nValues
                resampleFromList{i} = axisValueList(resampleFromList{i});
            end
            
            ci.axisRandomizeModes(idx) = ci.AxisResampledFromSpecified;
            ci.axisRandomizeResampleFromList{idx} = resampleFromList;
            ci.axisRandomizeWithReplacement(idx) = replace;

            ci = ci.invalidateCache();
        end
        
        function ci = axisResampleFromSpecifiedValues(ci, axisIdxOrAttr, resampleFromList, replace) 
            % resampleFromList specifies a set of value specifiers
            ci.warnIfNoArgOut(nargout);
            if nargin < 4
                replace = false;
            end
            ci = ci.newRandomSeedIfEmpty();
            aIdx = ci.axisLookupByAttributes(axisIdxOrAttr);
            assert(isscalar(aIdx), 'Method operates on only one axis');

            nValues = ci.nValuesAlongAxes(aIdx);
            if ischar(resampleFromList)
                resampleFromList = repmat({resampleFromList}, nValues, 1);
            elseif isscalar(resampleFromList)
                % all resampling from same, clone scalar value to to length of axis
                resampleFromList = repmat(resampleFromList, nValues, 1);
            end
            
            if ~isstruct(resampleFromList) && ~iscell(resampleFromList)
                % values specified as numbers, okay if single attribute,
                % convert to struct array with single attribute as the
                % field name
                nAttr = numel(ci.axisAttributes{aIdx});
                assert(nAttr == 1, 'Must specify values as struct for multi-attribute axes');
                resampleFromList = struct(ci.axisAttributes{aIdx}{1}, num2cell(resampleFromList));
            end
            
            assert(numel(resampleFromList) == nValues, 'Resample from list must match number of values along axis');
            
            if iscell(resampleFromList)
                nAttr = numel(ci.axisAttributes{aIdx});
                list = resampleFromList;
                for i = 1:numel(list)
                    if ~isstruct(list{i})
                        assert(nAttr == 1, 'Must specify values as struct for multi-attribute axes');
                        if ischar(list{i}) || iscell(list{i})
                            resampleFromList{i} = struct(ci.axisAttributes{aIdx}{1}, list{i});
                        else
                            resampleFromList{i} = struct(ci.axisAttributes{aIdx}{1}, num2cell(list{i}));
                        end
                    end
                end
            end
            
            if isstruct(resampleFromList)
                % split struct array into separate cells
                resampleFromList = num2cell(resampleFromList);
            end
            
%             % lookup each struct in the axis value list to convert to a
%             % subscript for storage
%             idxList = cellvec(nValues);
%             for iC = 1:nValues
%                 idxList{iC} = ci.axisLookupValueInValueList(aIdx, resampleFromList{iC});
%             end
            
            ci.axisRandomizeModes(aIdx) = ci.AxisResampledFromSpecified;
            ci.axisRandomizeResampleFromList{aIdx} = resampleFromList;
            ci.axisRandomizeWithReplacement(aIdx) = replace;

            ci = ci.invalidateCache();
        end
    end
    
    methods % Axis permutation and reshaping
        function ci = reshapeAxes(ci, varargin)
            % reshape the conditions tensor by permuting and combining axes
            % successive arguments are either scalars or vectors of scalars
            % which index into axes numerically, or strings, cellstrings, or cell
            % arrays of cellstrings which index into axes by attribute contents
            ci.warnIfNoArgOut(nargout);
            nArgs = numel(varargin);
            newValueListModes = nan(nArgs, 1);
            [newAxisAttributes, newAxisValueListsManual] = deal(cell(nArgs, 1));
            
            foundWildcard = false;
            idxByArg = cell(nArgs, 1);
            for iArg = 1:nArgs
                % lookup which axes this arg refers to
                arg = varargin{iArg};
                if isempty(arg)
                    idx = []; % refers to no-axes and will be a singleton dimension
                elseif ischar(arg) 
                    % '*' matches remaining axes, compute this after first
                    % pass is finished
                    if strcmp(arg, '*')
                        if foundWildcard > 0
                            error('Cannot specify multiple ''*'' wildcard matches');
                        else
                            foundWildcard = iArg;
                            idx = [];
                        end
                    else
                        idx = ci.axisLookupByAttributes(arg);
                    end
                elseif isscalar(arg) || isnumeric(arg)
                    idx = arg;
                elseif iscellstr(arg)
                    idx = ci.axisLookupByAttributes(arg);
                elseif iscell(arg)
                    idx = cellfun(@ci.axisLookupByAttributes, arg);
                else
                    error('Unknown argument specification');
                end
                
                idxByArg{iArg} = makecol(idx);
            end
              
            % now compute wildcard matches
            if foundWildcard > 0
                allIdx = cat(1, idxByArg{:});
                remaining = setdiff(1:ci.nAxes, allIdx);
                idxByArg{foundWildcard} = remaining;
            end
            
            for iArg = 1:nArgs
                idx = idxByArg{iArg};
                
                if isempty(idx)
                    % empty singleton axis
                    newAxisAttributes{iArg} = {};
                    newValueListModes(iArg) = ci.AxisValueListAutoAll;
                else
                    newAxisAttributes{iArg} = cat(1, ci.axisAttributes{idx});

                    % determine new axis value mode and build manual lists if
                    % necessary
                    isManual = ci.axisValueListModes(idx) == ci.AxisValueListManual;
                    isAutoOccupied = all(ci.axisValueListModes(idx) == ConditionDescriptor.AxisValueListAutoOccupied);

                    if any(isManual)
                        % at least one axis has a manual value list
                        if ~all(isManual)
                            % some are fixed, some are auto, must be an applied
                            % ConditionInfo 
                            if isa(ci, 'ConditionInfo') && ci.applied
                                % possible to fix the value list of the others
                                % ci = ci.fixAxisValueList(idx);
                                
                            else
                                error('Cannot determine axis value lists when some are automatic and some are manual and not yet applied to TrialData. Use fixAxisValueList or setAxisValueList to convert the appropriate axis value lists to manual');
                            end
                        end

                        % all are now manual 
                        % build combinatorial value list including the
                        % all axes along this
                        newValueListModes(iArg) = ci.AxisValueListManual;
                        newAxisValueListsManual{iArg} = ...
                            TensorUtils.buildCombinatorialStructTensor(ci.axisValueLists{idx});
                    else
                        % all are automatic
                        if isAutoOccupied
                            % preserve auto-occupied
                            newValueListModes(iArg) = ci.AxisValueListAutoOccupied;
                        else
                            newValueListModes(iArg) = ci.AxisValueListAutoAll;
                        end                  
                    end
                end
            end
                
            % install the new axes
            ci = ci.clearAxes();
            for iArg = 1:nArgs
                ci = ci.addAxis(newAxisAttributes{iArg});
                switch newValueListModes(iArg)
                    case ci.AxisValueListManual
                        ci.axisValueListsManual{iArg} = newAxisValueListsManual{iArg};
                    case ci.AxisValueListAutoAll
                        ci = ci.setAxisValueListAutoAll(iArg);
                    case ci.AxisValueListAutoOccupied
                        ci = ci.setAxisValueListAutoOccupied(iArg);
                end
            end
            ci = ci.invalidateCache();
        end
        
        function ci = flattenAxes(ci)
            % combine all axes into one, going from an nAxes-dimensional conditions
            % tensor to a long vector of conditions
            ci.warnIfNoArgOut(nargout);
            ci = ci.reshapeAxes(1:ci.nAxes);
        end
        
        function ci = flattenAxesExceptFirst(ci)
            % combine all axes 2:end into one, going from an nAxes-dimensional conditions
            % tensor to a size(conditions, 1) x N matrix of conditions
            ci.warnIfNoArgOut(nargout);
            if ci.nAxes > 1
                ci = ci.reshapeAxes(1, 2:ci.nAxes);
            end
        end
        
        function [ci, maskC] = selectConditions(ci, mask)
            % select specific conditions by linear index or mask
            % and return a single-axis condition descriptor with just those
            % conditions selected
            ci.warnIfNoArgOut(nargout);
            idx = ci.conditionsAsLinearInds(mask);
            attr = ci.attributeNames(~isnan(ci.attributeAlongWhichAxis));
            valList = ci.conditionsAxisAttributesOnly;
            valList = valList(idx);
            
            maskC = TensorUtils.vectorIndicesToMask(mask, ci.nConditions);
            
            ci = ci.clearAxes();
            ci = ci.addAxis(attr, 'valueList', valList);
        end
        
        function [ci, maskC] = selectConditionsAlongAxis(ci, axisAttr, mask)
            % select specific conditions along an axis specified by
            % axisAttr. mask can be a logical or linear mask.
            %
            % maskC is the mask into .conditions that indicates which
            % conditions will be kept.
            ci.warnIfNoArgOut(nargout);
            aIdx = ci.axisLookupByAttributes(axisAttr);
            valList = ci.axisValueLists{aIdx};      
            valList = valList(mask);
            
            % compute this before changing conditions
            if nargout > 1
                maskC = TensorUtils.maskSelectAlongDimension(ci.conditionsSize, aIdx, mask);
            end
            
            ci = ci.setAxisValueList(aIdx, valList);
        end
        
        function [ci, maskC] = matchSelectConditionsAlongAxis(ci, axisAttr, match)
            % select specific conditions along an axis specified by
            % axisAttr. match can be a struct which matches against the
            % conditions or an array of values for axes with only one
            % attribute
            ci.warnIfNoArgOut(nargout);
            aIdx = ci.axisLookupByAttributes(axisAttr);
            valList = ci.axisValueLists{aIdx};    
            
            [~, mask] = ci.axisLookupValueInValueList(aIdx, match);
     
            % do this before changing conditions
            if nargout > 1
                maskC = TensorUtils.maskSelectAlongDimension(ci.conditionsSize, aIdx, mask);
            end
            
            valList = valList(mask);
            ci = ci.setAxisValueList(aIdx, valList);
            
        end
        
        function [idx, mask] = axisLookupValueInValueList(ci, axisAttr, match)
            % find a specific attribute value or set of attribute values
            % (specified as a struct) along a specific axis. if match is a
            % struct array, the union of all matches is taken. unspecified
            % fields will act as wildcards, matching all possible values
            % taken along the axis
            aIdx = ci.axisLookupByAttributes(axisAttr);
            valList = ci.axisValueLists{aIdx};    
            
            nAttr = numel(ci.axisAttributes{aIdx});
            if ~isstruct(match)
                assert(nAttr == 1, 'Must specify struct array to match against when multiple attributes on axis');

                % for single attribute axes, convert to a match struct to
                % make the search the same as for multi-attribute axes
                if ~iscell(match)
                    match = num2cell(match);
                end
                match = struct(ci.axisAttributes{aIdx}{1}, match);
            end
            
            % remove the irrelevant (unspecified in match) fields from
            % valueList
            valListMatch = rmfield(valList, setdiff(fieldnames(valList), fieldnames(match)));
            % match the struct in the value list
            % if match is an array, the union of values matched by each 
            mask = false(numel(valList), 1);
            for c = 1:numel(valListMatch)
                for v = 1:numel(match)
                    if isequal(match(v), valListMatch(c))
                        mask(v) = true;
                        break;
                    end
                end
            end
            
            idx = find(mask);
        end
    end

    methods % Appearance modification fn
        function ci = clearAppearanceModifications(ci)
            ci.warnIfNoArgOut(nargout);
            ci.appearanceColorByAttributesList = [];
            ci.appearanceColorByAttributesCmap = [];
            ci.appearanceColorByAxesList = [];
            ci.appearanceColorByAxesCmap = [];
        end
        
        function ci = colorByAttributes(ci, attributes, varargin)
            p = inputParser();
            p.addOptional('cmapFn', @TrialDataUtilities.Colormaps.linspecer, ...
                @(x) ismatrix(x) || isa(x, 'function_handle'));
            p.parse(varargin{:});
            
            ci = ci.clearAppearanceModifications();
            
            ci.warnIfNoArgOut(nargout);
            if ~iscell(attributes), attributes = {attributes}; end
            ci.appearanceColorByAttributesList = attributes;
            ci.appearanceColorByAttributesCmap = p.Results.cmapFn;
            ci = ci.invalidateAppearanceInfo();
        end
        
        function ci = colorByAxes(ci, axesSpec, varargin)
            p = inputParser();
            p.addOptional('cmapFn', @TrialDataUtilities.Colormaps.linspecer, ...
                @(x) ismatrix(x) || isa(x, 'function_handle'));
            p.parse(varargin{:});
            
            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(axesSpec);
            
            ci = ci.clearAppearanceModifications();
            % want list to be cell of cellstr
            if ~iscell(axesSpec), axesSpec = {axesSpec}; end
            if iscellstr(axesSpec), axesSpec = {axesSpec}; end
            ci.appearanceColorByAxesList = axesSpec;
            ci.appearanceColorByAxesCmap = p.Results.cmapFn; 
        end
        
        function appear = applyAppearanceModifications(ci, appear)
            if ~isempty(ci.appearanceColorByAttributesList)
                % Color by attributes
                list = ci.appearanceColorByAttributesList;
                
                % remove attributes not in use along an axis
                list = setdiff(list, ci.attributeNames(isnan(ci.attributeAlongWhichAxis)));
                if isempty(list), return, end
               
                % generate combinatorial list of attribute values
                valueList = cell(numel(list), 1);
                for i = 1:numel(list)
                    vals = ci.getAttributeValueList(list{i});
                    if ~iscell(vals), vals = num2cell(vals); end
                    valueList{i} = struct(list{i}, vals);
                end
                combined = TensorUtils.buildCombinatorialStructTensor(valueList{:});
                nVals = numel(combined);
                
                cmap = ci.appearanceColorByAttributesCmap;
                if isa(cmap, 'function_handle')
                    cmap = cmap(nVals);
                end
                
                % match appearances to attribute value sets
                for c = 1:numel(appear)
                    cond = ci.conditions(c);
                    for v = 1:numel(combined)
                        if isequal(rmfield(cond, setdiff(fieldnames(cond), list)), combined(v))
                            if iscell(cmap)
                                appear(c).Color = cmap{v};
                            else
                                appear(c).Color = cmap(v, :);
                            end
                        end
                    end
                end
                
            elseif ~isempty(ci.appearanceColorByAxesList)
                % color by axes
                list = ci.appearanceColorByAxesList;
                
                allAttr = [list{:}];
               
                % generate combinatorial list of axis value values
                valueList = cell(numel(list), 1);
                for i = 1:numel(list)
                    valueList{i} = ci.getAxisValueList(list{i});
                end
                combined = TensorUtils.buildCombinatorialStructTensor(valueList{:});
                nVals = numel(combined);
                
                cmap = ci.appearanceColorByAxesCmap;
                if isa(cmap, 'function_handle')
                    cmap = cmap(nVals);
                end
                
                % match appearances to attribute value sets
                for c = 1:numel(appear)
                    cond = ci.conditions(c);
                    for v = 1:numel(combined)
                        if isequal(rmfield(cond, setdiff(fieldnames(cond), allAttr)), combined(v))
                            if iscell(cmap)
                                appear(c).Color = cmap{v};
                            else
                                appear(c).Color = cmap(v, :);
                            end
                        end
                    end
                end
            end    
        end
    end
    
    methods % Attribute related 
        function [tf, idx] = hasAttribute(ci, name)
            if isnumeric(name)
                [tf, idx] = ismember(name, 1:ci.nAttributes);
            else
                [tf, idx] = ismember(name, ci.attributeNames);
            end
        end

        function idx = assertHasAttribute(ci, name)
            [tf, idx] = ci.hasAttribute(name);
            if ~all(tf)
                if isnumeric(name)
                    name = strjoin(name(~tf), ', ');
                elseif iscell(name)
                    name = strjoin(name(~tf));
                end
                error('Attribute(s) %s not found', name);
            end
        end

        function na = get.nAttributes(ci)
            na = length(ci.attributeNames);
        end

        function idxList = getAttributeIdx(ci,name)
            if isempty(name)
                idxList = [];
                return;
            end
            
            if isnumeric(name)
                % already idx, just return
                idxList = floor(name);
                idxList(idxList < 0 | idxList > ci.nAttributes) = NaN;
                return;
            end
            
            if ~iscell(name)
                name = {name};
            end

            idxList = nan(length(name), 1);
            for i = 1:length(name)
                if ischar(name{i})
                    idx = find(strcmp(ci.attributeNames, name{i}), 1);
                else
                    idx = name{i};
                end
                if isempty(idx)
                    error('Cannot find attribute named %s', name{i});
                end
                idxList(i) = idx;
            end
        end
        
        function tf = getIsAttributeNumeric(ci, name)
            idx = ci.getAttributeIdx(name);
            tf = ci.attributeNumeric(idx);
        end
        
        % return an A x 1 numeric array of constants in the AttributeValue*
        % set listed above, describing how this attribute's values are
        % determined
        function modes = get.attributeValueModes(ci)
            % check for manual value list, then manual bins, then auto
            % bins, otherwise auto value list
            modes = nanvec(ci.nAttributes);
            for i = 1:ci.nAttributes
                if ~isempty(ci.attributeValueListsManual{i})
                    modes(i) = ci.AttributeValueListManual;
                elseif ~isempty(ci.attributeValueBinsManual{i})
                    modes(i) = ci.AttributeValueBinsManual;
                elseif ~isnan(ci.attributeValueBinsAutoCount(i))
                    modes(i) = ci.attributeValueBinsAutoModes(i);
                else
                    modes(i) = ci.AttributeValueListAuto;
                end
            end
        end

        % determine the number of attributes, where possible, otherwise
        % leave as NaN. returns A x 1 numeric array
        function nv = get.nValuesByAttribute(ci)
            nv = nanvec(ci.nAttributes);
            for i = 1:ci.nAttributes
                nv(i) = numel(ci.attributeValueLists{i});
            end
        end

        function desc = get.attributeDescriptions(ci)
            desc = ci.generateAttributeDescriptions();
        end
        
        function desc = generateAttributeDescriptions(ci, useColor)
            if nargin < 2
                useColor = false;
            end
            desc = cellvec(ci.nAttributes);
            isFilter = ci.attributeActsAsFilter;
            modes = ci.attributeValueModes;
            for i = 1:ci.nAttributes
                name = ci.attributeNames{i};  
                nValues = ci.nValuesByAttribute(i);
                nAutoBins = ci.attributeValueBinsAutoCount(i);

                switch modes(i)
                    case ci.AttributeValueListManual
                        suffix = sprintf('(%d)', nValues);
                    case ci.AttributeValueListAuto
                        suffix = sprintf('(%d auto)', nValues);
                    case ci.AttributeValueBinsManual
                        suffix = sprintf('(%d bins)', nValues);
                    case ci.AttributeValueBinsAutoUniform
                        suffix = sprintf('(%d uniform-bins)', nAutoBins);
                    case ci.AttributeValueBinsAutoQuantiles
                        suffix = sprintf('(%d quantiles)', nAutoBins);
                end
                
                if isFilter(i)
                    filterStr = ' [filter]';
                else
                    filterStr = '';
                end

                if ci.attributeNumeric(i)
                    numericStr = '#';
                else
                    numericStr = '@';
                end
                if ~useColor
                    desc{i} = sprintf('%s %s%s%s', name, numericStr, suffix, filterStr);
                else
                    desc{i} = sprintf('{purple}%s {darkGray}%s%s%s', name, numericStr, suffix, filterStr);
                end
            end
        end 

        % add a new attribute
        function ci = addAttribute(ci, name, varargin)
            ci.warnIfNoArgOut(nargout);

            p = inputParser;
            p.addRequired('name', @ischar);
            % is this attribute always numeric?
            % list of allowed values for this value (other values will be ignored)
            p.addParameter('requestAs', '', @ischar);
            p.addParameter('valueList', {}, @(x) islogical(x) || isnumeric(x) || iscell(x)); 
            p.addParameter('valueBins', {}, @(x) isnumeric(x) || iscell(x));
            p.parse(name, varargin{:});
            valueList = p.Results.valueList;
            requestAs = p.Results.requestAs;
            if isempty(requestAs)
                requestAs = name;
            end

            if ci.hasAttribute(name)
                error('ConditionDescriptor already has attribute %s', name);
            end
            
            iAttr = ci.nAttributes + 1;
            ci.attributeNames{iAttr} = name;
            ci.attributeNumeric(iAttr) = isnumeric(valueList) || islogical(valueList); 
            ci.attributeRequestAs{iAttr} = requestAs;

            if isempty(valueList)
                ci.attributeValueListsManual{iAttr} = {};
            else
                %assert(isnumeric(valueList) || iscell(valueList), 'ValueList must be numeric or cell');
                % filter for unique values or 
                ci.attributeValueListsManual{iAttr} = unique(valueList, 'stable');
            %    if ~iscell(valueList)
             %       valueList = num2cell(valueList);
             %   end
            end

            ci.attributeValueBinsManual{iAttr} = [];
            ci.attributeValueBinsAutoCount(iAttr) = NaN;
            ci.attributeValueBinsAutoModes(iAttr) = NaN;

            ci = ci.invalidateCache();
        end

        function ci = addAttributes(ci, names)
            ci.warnIfNoArgOut(nargout);
            for i = 1:numel(names)
                ci = ci.addAttribute(names{i});
            end
        end
        
        % remove an existing attribute
        function ci = removeAttribute(ci, varargin)
            ci.warnIfNoArgOut(nargout);

            if iscell(varargin{1})
                attributes = varargin{1};
            else
                attributes = varargin;
            end

            ci.warnIfNoArgOut(nargout);

            if ~isnumeric(attributes)
                % check all exist
                ci.getAttributeIdx(attributes);
            else
                attributes = ci.attributeNames(attributes);
            end

            if ~ci.hasAttribute(attributes)
                error('ConditionDescriptor has no attribute %s', name);
            end

            iAttr = ci.getAttributeIdx(attributes);
            maskOther = true(ci.nAttributes, 1);
            maskOther(iAttr) = false;

            ci = ci.maskAttributes(maskOther);
        end
        
        function ci = maskAttributes(ci, mask)
            ci.warnIfNoArgOut(nargout);
            
            idxRemove = find(~mask);
            if ~any(idxRemove)
                return;
            end
            
            % first remove the attributes from any axes they are on
            ci = ci.removeAttributesFromAxes(idxRemove); 

            % then remove it from the attribute lists
            ci.attributeNames = ci.attributeNames(mask);
            ci.attributeRequestAs = ci.attributeRequestAs(mask);
            ci.attributeNumeric = ci.attributeNumeric(mask);
            ci.attributeValueListsManual = ci.attributeValueListsManual(mask);
            ci.attributeValueLists = ci.attributeValueLists(mask);
            ci.attributeValueListsAsStrings = ci.attributeValueListsAsStrings(mask);
            ci.attributeValueBinsAutoCount = ci.attributeValueBinsAutoCount(mask);
            ci.attributeValueBinsAutoModes = ci.attributeValueBinsAutoModes(mask);
            ci.attributeValueBinsManual = ci.attributeValueBinsManual(mask);
        end 
        
        % set all attribute value lists to auto
        function ci = setAllAttributeValueListsAuto(ci)
            ci.warnIfNoArgOut(nargout);
            for i = 1:ci.nAttributes
                ci = ci.setAttributeValueListAuto(i);
            end
        end
        
        % restore value list to automatically include all values, with no
        % binning
        function ci = setAttributeValueListAuto(ci, attr)
            ci.warnIfNoArgOut(nargout);
            iAttr = ci.assertHasAttribute(attr);
            ci.attributeValueListsManual{iAttr} = [];
            ci.attributeValueBinsManual{iAttr} = [];
            ci.attributeValueBinsAutoCount(iAttr) = NaN;
            ci.attributeValueBinsAutoModes(iAttr) = NaN;
            ci = ci.invalidateCache();
        end
        
        function ci = setAttributeNumeric(ci, attr, tf)
            ci.warnIfNoArgOut(nargout);
            iAttr = ci.assertHasAttribute(attr);
            ci.attributeNumeric(iAttr) = tf;
        end  

        % manually set the attribute value list
        function ci = setAttributeValueList(ci, name, valueList)
            ci.warnIfNoArgOut(nargout);

            iAttr = ci.getAttributeIdx(name);           
            if isempty(valueList)
                ci.attributeValueListsManual{iAttr} = {};
            else
                if ischar(valueList)
                    valueList = {valueList};
                end
                ci.attributeValueListsManual{iAttr} = valueList;                
            end
            
            %ci.attributeNumeric(iAttr) = isnumeric(valueList) || islogical(valueList);

            ci = ci.invalidateCache();
        end

        % manually set attribute bins
        function ci = binAttribute(ci, name, bins)
            ci.warnIfNoArgOut(nargout);

            if isvector(bins) && isnumeric(bins)
                assert(issorted(bins), 'Bins specified as vector must be in sorted order');
                binsMat = nan(numel(bins)-1, 2);
                binsMat(:, 1) = bins(1:end-1);
                binsMat(:, 2) = bins(2:end);
            elseif iscell(bins)
                binsMat = cell2mat(bins);
            else
                binsMat = bins;
            end
            
            assert(ismatrix(binsMat) && size(binsMat, 2) == 2, 'Bins matrix must be nBins x 2');
            assert(all(binsMat(:, 2) >= binsMat(:, 1)), 'Bins matrix must have larger value in second column than first');
            
            % convert nBins x 2 matrix to nBins x 1 cellvec 
            binsCell = mat2cell(binsMat, ones(size(binsMat, 1), 1), 2);

            iAttr = ci.getAttributeIdx(name); 
            ci.attributeValueBinsManual{iAttr} = binsCell;
            ci.attributeNumeric(iAttr) = true;
            ci.attributeValueListsManual{iAttr} = {};
            ci.attributeValueBinsAutoCount(iAttr) = NaN;
            ci.attributeValueBinsAutoModes(iAttr) = NaN;

            ci = ci.invalidateCache();
        end

        % automatically set attribute binned uniformly by range
        function ci = binAttributeUniform(ci, name, nBins)
            ci.warnIfNoArgOut(nargout);
            
            iAttr = ci.getAttributeIdx(name);

            ci.attributeValueBinsManual{iAttr} = [];
            ci.attributeNumeric(iAttr) = true;
            ci.attributeValueListsManual{iAttr} = {};
            ci.attributeValueBinsAutoCount(iAttr) = nBins;
            ci.attributeValueBinsAutoModes(iAttr) = ci.AttributeValueBinsAutoUniform;

            ci = ci.invalidateCache();
        end

        % automatically set attribute binned into quantiles
        function ci = binAttributeQuantiles(ci, name, nQuantiles)
            ci.warnIfNoArgOut(nargout);

            iAttr = ci.assertHasAttribute(name);
            ci.attributeValueBinsManual{iAttr} = [];
            ci.attributeNumeric(iAttr) = true;
            ci.attributeValueListsManual{iAttr} = {};
            ci.attributeValueBinsAutoCount(iAttr) = nQuantiles;
            ci.attributeValueBinsAutoModes(iAttr) = ci.AttributeValueBinsAutoQuantiles;

            ci = ci.invalidateCache();
        end
        
        function values = generateConditionsAsStrings(ci, varargin)
            % publically callable version of buildConditionsAsStrings in case build methods
            % end up having side effects
            p = inputParser();
            p.addOptional('separator', ' ', @ischar);
            p.addOptional('short', false, @islogical);
            p.parse(varargin{:});
            separator = p.Results.separator;
            short = p.Results.short;
            
            if ci.nAxes == 0
                values = {structToString(ci.conditions)};
            else
                valueLists = ci.generateAxisValueListsAsStrings(separator, short); 
                values = TensorUtils.mapFromAxisLists(@(varargin) strjoin(varargin, separator),...
                    valueLists, 'asCell', true);
            end
        end
        
        function ci = sortWithinConditionsBy(ci, sortByList)
            ci.warnIfNoArgOut(nargout);
            if ischar(sortByList)
                sortByList = {sortByList};
            end
            assert(iscellstr(sortByList), 'sortByList must be string or cellstr');
            
            % strip leading '-' to check has each attribute
            attrNames = cell(numel(sortByList), 1);
            for i = 1:numel(sortByList)
                if strncmp(sortByList{i}, '-', 1)
                    attrNames{i} = sortByList{i}(2:end);
                else
                    attrNames{i} = sortByList{i};
                end
            end
            ci.assertHasAttribute(attrNames);
            
            ci.attributeSortByList = makecol(sortByList(:));
        end
        
    end

    % get, set data stored inside odc
    methods 
        % NOTE: all of these should copy odc before writing to it
        
        function v = get.conditions(ci)
            v = ci.odc.conditions;
            if isempty(v)
                ci.odc.conditions = ci.buildConditions();
                v = ci.odc.conditions;
            end
        end
        
        function ci = set.conditions(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.conditions = v;
        end
        
        function v = get.conditionsAsStrings(ci)
            v = ci.odc.conditionsAsStrings;
            if isempty(v)
                ci.odc.conditionsAsStrings = ci.buildConditionsAsStrings();
                v = ci.odc.conditionsAsStrings;
            end
        end
        
        function ci = set.conditionsAsStrings(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.conditionsAsStrings = v;
        end
%         
%         function v = get.conditionsAsStringsWithFilters(ci)
%             v = ci.odc.conditionsAsStringsWithFilters;
%             if isempty(v)
%                 ci.odc.conditionsAsStringsWithFilters = ci.buildConditionsAsStringsWithFilters();
%                 v = ci.odc.conditionsAsStringsWithFilters;
%             end
%         end
%         
%         function ci = set.conditionsAsStringsWithFilters(ci, v)
%             ci.odc = ci.odc.copy();
%             ci.odc.conditionsAsStringsWithFilters = v;
%         end
        
        function v = get.conditionsAxisAttributesOnly(ci)
            v = ci.odc.conditionsAxisAttributesOnly;
            if isempty(v)
                ci.odc.conditionsAxisAttributesOnly = ci.buildConditionsAxisAttributesOnly();
                v = ci.odc.conditionsAxisAttributesOnly;
            end
        end
        
        function ci = set.conditionsAxisAttributesOnly(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.conditionsAxisAttributesOnly = v;
        end
        
        function v = get.appearances(ci)
            v = ci.odc.appearances;
            if isempty(v)
                ci.odc.appearances = ci.buildAppearances();
                v = ci.odc.appearances;
            end
        end
        
        function ci = set.appearances(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.appearances = v;
        end
        
        function v = get.names(ci)
            v = ci.odc.names;
            if isempty(v)
                ci.odc.names = ci.buildNames();
                v = ci.odc.names;
            end
        end 
        
        function ci = set.names(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.names = v;
        end
        
        function v = get.namesShort(ci)
            v = ci.odc.namesShort;
            if isempty(v)
                ci.odc.namesShort = ci.buildNamesShort();
                v = ci.odc.namesShort;
            end
        end 
        
        function ci = set.namesShort(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.namesShort = v;
        end
        
        function v = get.namesMultiline(ci)
            v = ci.odc.namesMultiline;
            if isempty(v)
                ci.odc.namesMultiline = ci.buildNamesMultiline();
                v = ci.odc.namesMultiline;
            end
        end 
        
        function ci = set.namesMultiline(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.namesMultiline = v;
        end
        
        function v = get.attributeValueLists(ci)
            v = ci.odc.attributeValueLists;
            if isempty(v)
                ci.odc.attributeValueLists = ci.buildAttributeValueLists();
                v = ci.odc.attributeValueLists;
            end
        end
        
        function ci = set.attributeValueLists(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.attributeValueLists = v;
        end
        
        function v = get.attributeValueListsAsStrings(ci)
            v = ci.odc.attributeValueListsAsStrings;
            if isempty(v)
                ci.odc.attributeValueListsAsStrings = ci.buildAttributeValueListsAsStrings();
                v = ci.odc.attributeValueListsAsStrings;
            end
        end
        
        function ci = set.attributeValueListsAsStrings(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.attributeValueListsAsStrings = v;
        end

        function v = get.axisValueLists(ci)
            v = ci.odc.axisValueLists;
            if isempty(v)
                ci.odc.axisValueLists = ci.buildAxisValueLists();
                v = ci.odc.axisValueLists;
            end
        end

        function ci = set.axisValueLists(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.axisValueLists = v;
        end
        
        function v = get.axisValueListsAsStrings(ci)
            v = ci.odc.axisValueListsAsStrings;
            if isempty(v)
                ci.odc.axisValueListsAsStrings = ci.buildAxisValueListsAsStrings();
                v = ci.odc.axisValueListsAsStrings;
            end
        end

        function ci = set.axisValueListsAsStrings(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.axisValueListsAsStrings = v;
        end
        
        function v = get.axisValueListsAsStringsShort(ci)
            v = ci.odc.axisValueListsAsStringsShort;
            if isempty(v)
                ci.odc.axisValueListsAsStringsShort = ci.buildAxisValueListsAsStringsShort();
                v = ci.odc.axisValueListsAsStringsShort;
            end
        end

        function ci = set.axisValueListsAsStringsShort(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.axisValueListsAsStringsShort = v;
        end
    end

    % build data stored inside odc (used by getters above)
    methods 
        function values = buildConditionsAxisAttributesOnly(ci)
            if ci.nAxes == 0
                values = struct();
            else
                valueLists = ci.axisValueLists; 
                values = TensorUtils.mapFromAxisLists(@structMergeMultiple,...
                    valueLists, 'asCell', false);
                if isempty(values)
                    values = struct([]);
                end
            end
        end
        
        function values = buildConditions(ci)
            values = ci.conditionsAxisAttributesOnly;
            
            if isempty(values)
                return;
            end
            
            % and add "wildcard" match for all other attributes that act as
            % filter (i.e. have manual value list or bins specified)
            whichAxis = ci.attributeAlongWhichAxis;
            isFilter = ci.attributeActsAsFilter;
            valueLists = ci.attributeValueLists;
            for iA = 1:ci.nAttributes
                if isnan(whichAxis(iA)) && isFilter(iA)
                    valueList = valueLists{iA};
                    
                    % flatten any subgroupings of values in the value list
                    if ci.attributeNumeric(iA) && iscell(valueList)
                        valueList = [valueList{:}];
                    elseif ~ci.attributeNumeric(iA) && ~iscellstr(valueList) && ~ischar(valueList)
                        valueList = [valueList{:}];
                    end
                    % wrap in cell to avoid scalar expansion
                    values = assignIntoStructArray(values, ci.attributeNames{iA}, {valueList});
                end
            end
        end
        
        % build a wildcard search struct where each .attribute field is the
        % value list for that attribute
        function values = buildStructAllAttributeValueLists(ci)
            values = struct();
            for iA = 1:ci.nAttributes
                values = assignIntoStructArray(values, ci.attributeNames{iA}, ...
                    ci.attributeValueLists(iA));
            end
        end
        
        function values = buildStructNonAxisAttributeValueLists(ci)
            whichAxis = ci.attributeAlongWhichAxis;
            values = struct();
            for iA = 1:ci.nAttributes
                if isnan(whichAxis(iA))
                    values = assignIntoStructArray(values, ci.attributeNames{iA}, ...
                        ci.attributeValueLists(iA));
                end
            end
        end
        
        function values = buildConditionsAsStrings(ci, separator)
            if nargin < 2
                separator = ' ';
            end
            if ci.nAxes == 0
                values = {structToString(ci.conditions)};
            else
                valueLists = ci.axisValueListsAsStrings; 
                values = TensorUtils.mapFromAxisLists(@(varargin) strjoin(varargin, separator),...
                    valueLists, 'asCell', true);
            end
        end
        
        function valueListByAxes = buildAxisValueLists(ci)
            valueListByAxes = cellvec(ci.nAxes);
            for iX = 1:ci.nAxes
                % build a cellstr of descriptions of the values along this axis
               
                % G x 1 cell of cells: each contains a struct specifying an attribute specification for each element along the axis
                if isempty(ci.axisValueListsManual{iX})
                    % build auto list of attributes
                    valueListByAxes{iX} = makecol(buildAutoValueListForAttributeSet(ci.axisAttributes{iX}));
                else
                    valueListByAxes{iX} = makecol(ci.axisValueListsManual{iX});
                end
                
                valueListByAxes{iX} = makecol(valueListByAxes{iX}(:));
            end

            function values = buildAutoValueListForAttributeSet(attributes)
                % build a struct array for a set of attributes that walks all possible combinations of the attribute values 
                if isempty(attributes)
                    % for singleton axes, only one empty value
                    values = struct();
                    return;
                end
                
                if ischar(attributes)
                    attributes = {attributes};
                end
                attrIdx = ci.getAttributeIdx(attributes);
                valueLists = ci.attributeValueLists(attrIdx);

                % convert bin edges value lists to the cell vectors
                for i = 1:numel(attrIdx)
                    switch ci.attributeValueModes(attrIdx(i))
                        case {ci.AttributeValueBinsManual, ci.AttributeValueBinsAutoUniform, ...
                                ci.AttributeValueBinsAutoQuantiles}
                            % convert valueList from Nbins x 2 matrix to
                            % Nbins x 1 cellvector so that it gets mapped
                            % correctly
                            valueLists{i} = mat2cell(valueLists{i}, ones(size(valueLists{i}, 1), 1));
                    end
                end
                            
                values = TensorUtils.mapFromAxisLists(@buildStruct, valueLists, ...
                    'asCell', false);

                function s = buildStruct(varargin)
                    for j = 1:numel(varargin)
                        s.(attributes{j}) = varargin{j};
                    end
                end

            end
        end
        
        function strCell = buildAxisValueListsAsStrings(ci)
            strCell = ci.generateAxisValueListsAsStrings(' ');
        end
        
        function strCell = buildAxisValueListsAsStringsShort(ci)
            strCell = ci.generateAxisValueListsAsStrings(' ', true);
        end
        
        
        function strCell = generateAxisValueListsAsStrings(ci, separator, shortNames)
            if nargin < 2
                separator = ' ';
            end
            if nargin < 3
                shortNames = false;
            end
            strCell = cellvec(ci.nAxes);
            valueLists = ci.axisValueLists;
            randStrCell = ci.axisRandomizeModesAsStrings;
            
            % describe the list of values selected for along each position on each axis
            for iX = 1:ci.nAxes  
                
                % start with axisValueLists
                attr = ci.axisAttributes{iX};
                attrIdx = ci.getAttributeIdx(attr);
                
                % replace binned values with strings
                for iA = 1:numel(attrIdx)
                    switch ci.attributeValueModes(attrIdx(iA))
                        case {ci.AttributeValueBinsManual, ci.AttributeValueBinsAutoUniform, ...
                                ci.AttributeValueBinsAutoQuantiles}
                            % convert valueList from 1 x 2 vector to '#-#' string
                            for iV = 1:numel(valueLists{iX})
                                if ~iscellstr(valueLists{iX}(iV).(attr{iA}))
                                    valueLists{iX}(iV).(attr{iA}) = sprintf('%.3g-%.3g', cell2mat(valueLists{iX}(iV).(attr{iA})));
                                end
                            end
                    end
                end
                
                strCell{iX} = arrayfun(@(v) TrialDataUtilities.Data.structToString(v, ...
                    separator, 'includeFieldNames', ~shortNames), ...
                    makecol(valueLists{iX}), ...
                   'UniformOutput', false);

                % append randomization indicator when axis is randomized
                if ci.axisRandomizeModes(iX) ~= ci.AxisOriginal && ~shortNames
                    if ci.axisRandomizeModes(iX) == ci.AxisResampledFromSpecified
                        % indicate which attribute 
                        strCell{iX} = cellfun(@(s, from) [s ' resampled from ' structToString(from)], ...
                            strCell{iX}, ci.axisRandomizeResampleFromList{iX}, 'UniformOutput', false);
                    else
                        strCell{iX} = cellfun(@(s) [s ' ' randStrCell{iX}], strCell{iX}, 'UniformOutput', false);
                    end
                end
            end
        end

        function names = buildNames(ci)
            % pass along values(i) and the subscripts of that condition in case useful 
            if ci.nConditions > 0
                fn = ci.nameFn;
                if isempty(fn)
                    fn = @ConditionDescriptor.defaultNameFn;
                end
                names = fn(ci, 'multiline', false);
                assert(iscellstr(names) && TensorUtils.compareSizeVectors(size(names), ci.conditionsSize), ...
                    'nameFn must return cellstr with same size as .conditions');
            else
                names = {};
            end
        end
        
        function names = buildNamesShort(ci)
            % pass along values(i) and the subscripts of that condition in case useful 
            if ci.nConditions > 0
                fn = ci.nameFn;
                if isempty(fn)
                    fn = @ConditionDescriptor.defaultNameFn;
                end
                names = fn(ci, 'multiline', false, 'shortNames', true);
                assert(iscellstr(names) && TensorUtils.compareSizeVectors(size(names), ci.conditionsSize), ...
                    'nameFn must return cellstr with same size as .conditions');
            else
                names = {};
            end
        end
        
        function names = buildNamesMultiline(ci)
            % pass along values(i) and the subscripts of that condition in case useful 
            if ci.nConditions > 0
                fn = ci.nameFn;
                if isempty(fn)
                    fn = @ConditionDescriptor.defaultNameFn;
                end
                % multiline true
                names = fn(ci, 'multiline', true);
                assert(iscellstr(names) && TensorUtils.compareSizeVectors(size(names), ci.conditionsSize), ...
                    'nameFn must return cellstr with same size as .conditions');
            else
                names = {};
            end
        end

        function appearances = buildAppearances(ci)
            if ci.nConditions > 0
                appearFn = ci.appearanceFn;

                appearances = ci.defaultAppearanceFn();
                if ~isempty(appearFn)
                    appearances = appearFn(ci, appearances);
                end
                
                appearances = ci.applyAppearanceModifications(appearances);
            else
                appearances = [];
            end
        end

        function valueList = buildAttributeValueLists(ci)
            % just pull the manual lists (ConditionInfo will deal
            modes = ci.attributeValueModes;
            valueList = cellvec(ci.nAttributes);
            for i = 1:ci.nAttributes
                switch modes(i) 
                    case ci.AttributeValueListManual
                        valueList{i} = ci.attributeValueListsManual{i};
                    case ci.AttributeValueBinsManual
                        valueList{i} = ci.attributeValueBinsManual{i};
                    case ci.AttributeValueBinsAutoUniform
                        % placeholder string to be replaced by actual bins
                        % matrix
                        valueList{i} = arrayfun(@(bin) sprintf('bin%d', bin), ...
                            1:ci.attributeValueBinsAutoCount(i), 'UniformOutput', false);
                    case ci.AttributeValueBinsAutoQuantiles
                        % the number of bins is known, so they can be specified here
                        valueList{i} = arrayfun(@(bin) sprintf('quantile%d', bin), ...
                            1:ci.attributeValueBinsAutoCount(i), 'UniformOutput', false);
                    otherwise
                         % place holder, must be determined when
                        % ConditionInfo applies it to data
                        if ci.attributeNumeric(i)
                            valueList{i} = NaN;
                        else
                            valueList{i} = {'?'};
                        end
                end
                valueList{i} = makecol(valueList{i});
            end
        end
        
        function valueList = buildAttributeValueListsAsStrings(ci)
            modes = ci.attributeValueModes;
            valueList = ci.attributeValueLists;
            for i = 1:ci.nAttributes
                switch modes(i) 
                    case ci.AttributeValueListManual
                        if ci.attributeNumeric(i)
                            if iscell(valueList{i})
                                % could have multiple attribute values
                                % grouped together as one element
                                valueList{i} = cellfun(@(i) sprintf('%.3g', i), valueList{i}, 'UniformOutput', false);
                                valueList{i} = cellfun(@(vals) strjoin(vals, ','), valueList{i}, 'UniformOutput', false);
                            else
                                valueList{i} = arrayfun(@(i) sprintf('%.3g', i), valueList{i}, 'UniformOutput', false);
                            end
                        else
                            % non-numeric, can leave as is unless...
                            if ~iscellstr(valueList{i})
                                % could have multiple attribute values
                                % grouped together as one element
                                valueList{i} = cellfun(@(vals) strjoin(vals, ','), valueList{i}, 'UniformOutput', false);
                            end
                        end
                                
                    case {ci.AttributeValueBinsManual, ci.AttributeValueBinsAutoUniform, ci.AttributeValueBinsAutoQuantiles}
                        if ~iscellstr(valueList{i})
                            if ~iscell(valueList{i})
                                bins = valueList{i};
                            else
                                bins = cat(1, valueList{i}{:});
                            end
                            valueList{i} = arrayfun(@(row) sprintf('%.3g-%.3g', bins(row, 1), bins(row, 2)), ...
                                1:size(bins, 1), 'UniformOutput', false);
                        end
                        
                    case ci.AttributeValueListAuto
                        % auto list leave empty, must be determined when
                        % ConditionInfo applies it to data
                        valueList{i} = {'?'};   
                end
                valueList{i} = makecol(valueList{i});
            end
        end

        function valueList = getAttributeValueList(ci, name)
            idx = ci.getAttributeIdx(name);
            valueList = makecol(ci.attributeValueLists{idx});
        end
        
        function mode = getAttributeValueListMode(ci, name)
            idx = ci.getAttributeIdx(name);
            mode = ci.attributeValueModes(idx);
        end
        
        function tf = getIsAttributeBinned(ci, name)
            mode = ci.getAttributeValueListMode(name);
            tf = ismember(mode, [ci.AttributeValueBinsManual, ...
                ci.AttributeValueBinsAutoUniform, ...
                ci.AttributeValueBinsAutoQuantiles]);
        end

        function valueIdx = getAttributeValueIdx(ci, attr, value)
            [tf, valueIdx] = ismember(value, ci.getAttributeValueLists(attr));
            assert(tf, 'Value not found in attribute %s valueList', attr);
        end
        
        function a = defaultAppearanceFn(ci, varargin)
            % returns a AppearSpec array specifying the default set of appearance properties 
            % for the given group. indsGroup is a length(ci.groupByList) x 1 array
            % of the inds where this group is located in the high-d array, and dimsGroup
            % gives the full dimensions of the list of groups.
            %
            % We vary color along all axes simultaneously, using the linear
            % inds.
            %
            % Alternatively, if no arguments are passed, simply return a set of defaults

            nConditions = ci.nConditions;

            a = repmat(AppearanceSpec(), ci.conditionsSize);

            if nConditions == 1
                cmap = [0.3 0.3 1];
            else
                if nConditions > 256
                    cmap = jet(nConditions);
                else
                    cmap = distinguishable_colors(nConditions);
                end
            end

            for iC = 1:nConditions
                a(iC).Color = cmap(iC, :);
            end
        end
    end
    
    methods(Static) % Default nameFn and appearanceFn
        function nameCell = defaultNameFn(ci, varargin) 
            % receives the condition descriptor itself and returns a
            %  a cell tensor specifying the names of each condition
            p = inputParser();
            p.addParameter('multiline', false, @islogical);
            p.addParameter('shortNames', false, @islogical);
            p.KeepUnmatched = true;
            p.parse(varargin{:});
            
            if p.Results.multiline
                separator = char(10);
            else
                separator = ' ';
            end
            nameCell = ci.generateConditionsAsStrings(separator, p.Results.shortNames);
        end
    end

    methods(Static) % construct from another condition descriptor, used primarily by ConditionInfo
        function cdNew = fromConditionDescriptor(cd, cdNew)
            cd.warnIfNoArgOut(nargout);
            
            if nargin < 2
                cdNew = ConditionDescriptor();
            end

            meta = ?ConditionDescriptor;
            props = meta.PropertyList;

            for iProp = 1:length(props)
                prop = props(iProp);
                if prop.Dependent || prop.Constant || prop.Transient
                    continue;
                else
                    name = prop.Name;
                    cdNew.(name) = cd.(name);
                end
            end

            cdNew.odc = ConditionDescriptorOnDemandCache();
            
            cdNew = cdNew.invalidateCache();
        end
        
        % construct condition descriptor from a struct of attribute values
        % for numeric attributes, if there are more than 10 different
        % values, the attribute will be binned into quintiles
        function cd = fromStruct(s)
            cd = ConditionDescriptor();
            cd = cd.addAttributes(fieldnames(s));
        end
    end
    
    methods
        function cd = getConditionDescriptor(cd)
            % this does nothing here since it's already a condition
            % descriptor. This is used for "casting" back to ConditionDescriptor 
            % from subclasses.
            cd.warnIfNoArgOut(nargout);
        end
        
        function cdManual = fixValueListsByApplyingToTrialData(cd, td)
            % converts automatic attribute and axis value lists to manual
            % lists, by building a ConditionInfo instance, applying to a
            % TrialData instance, fixing all value lists, and converting
            % back to a condition descriptor
            cd.warnIfNoArgOut(nargout);
            ci = ConditionInfo.fromConditionDescriptor(cd, td);
            cdManual = ci.getFixedConditionDescriptor();
        end
    end

    methods(Access=protected) % Utility methods
        function warnIfNoArgOut(obj, nargOut)
            if nargOut == 0 && ~isa(obj, 'handle')
                warning('WARNING: %s is not a handle class. If the instance handle returned by this method is not stored, this call has no effect.\\n', ...
                    class(obj));
            end
        end
        
        function obj = copyIfHandle(obj)
            if isa(obj, 'handle')
                obj = obj.copy(); %#ok<MCNPN>
            end
        end
    end
end

