classdef ConditionDescriptor
% ConditionDescriptor is a static representation of a A-dimensional combinatorial
% list of attribute values

    % the following properties are computed dynamically on the fly as they
    % are easy to compute
    properties(Dependent, Transient)
        nAttributes % how many attributes: ndims(values)
        nValuesByAttribute % how many values per attribute: size(values)

        nAxes % how many dimensions of grouping axe
        nValuesAlongAxes % X x 1 array of number of elements along the ax`is

        nConditions % how many total conditions
        conditionsSize % size of conditions, will have trailing 1 for single axis so can be passed to e.g. ones(conditionsSize)
        conditionsSizeNoExpand % size of conditions, will be length nAxes

        axisValueListIsManual
        allAxisValueListsManual

        attributeValueListIsManual
        allAttributeValueListsManual
        allValueListsManual % true if all attribute lists and axis lists are manually (not automatically determined)

        attributeValueListIsBinned
        axisValueListIsBinned
    end

    % the following properties are computed dynamically on the fly as they
    % are easy to compute
    properties(Dependent, Transient)
        attributeDisplayAs
        attributeDescriptions
        attributeAlongWhichAxis % A x 1 array indicating which axis an attribute contributes to (or NaN)
        attributeValueModes % A x 1 array of AttributeValue* constants above
        attributeActsAsFilter % A x 1 logical array : does this attribute have a
                % value list or manual bin setup that would invalidate trials?

        axisNames % strcell with a short name for each axis
        axisDescriptions % strcell describing each axis

        axisValueListModesAsStrings
        axisRandomizeModesAsStrings

        conditionsAsLinearInds % linear index corresponding to each condition if flattened

        conditionColors % A x 3 cell of colors

        % nConditions x 1 mask which indicates which conditions will be
        % suppressed in the final grouping into conditions
        % this is set using .setConditionIncludeMask after all grouping is
        % taken care of. the only effect will be to ignore trials that fall
        % into the specific conditions where conditionIncludeMask is true
        conditionIncludeMask

        % a short string summarizing the randomization applied to this
        % conditionDescriptor
        randomizationDescription

        % boolean determining whether there is any randomization
        hasRandomization
    end

    properties
        description = '';

        % updates cache on set

        % function which maps .values(i) struct --> name of condition i
        % called as nameFn(conditionInfo, 'multiline', tf) where
        % multiline=true means use \n to separate lines when appropriate
        nameFn

        % updates cache on set
        appearanceFn; % function which takes struct('attrName1', attrVal1, 'attrName2', attrVal2)
                      % and returns struct('color', 'k', 'lineWidth', 2, ...);

        logicalNotPrefix = 'Non-';
        includeUnits = true;
    end

    properties(SetAccess=protected)
        % modifications to appearances generated by appearanceFn,
        appearanceColorByAttributesList
        appearanceColorByAttributesCmap

        appearanceColorByAxesList
        appearanceColorByAxesCmap

        appearanceLineStyleByAttributesList
        appearanceLineStyleByAttributesMap
        appearanceLineStyleByAxesList
        appearanceLineStyleByAxesMap

        appearanceLineWidthByAttributesList
        appearanceLineWidthByAttributesMap
        appearanceLineWidthByAxesList
        appearanceLineWidthByAxesMap

        % A x 1 : by attribute
        attributeNames = {}; % A x 1 cell array : list of attributes for each dimension
%         attributeRequestAs = {}; % A x 1 cell array : list of names by which each attribute should be requested corresponding to attributeNames
        attributeDisplayAsManual = {}; % .attributeName = attribute display name for attributeName,

        axisAttributes % G x 1 cell : each is cellstr of attributes utilized along that grouping axis

        attributeSortByList = {}; % cellstr of attribute names (or '-attribute') specifying how to sort trials within each condition list
    end

    properties(SetAccess=protected, Hidden)
        attributeUnits = {}; % A x 1 cellstr array of units associated with each attribute, used for generating names
        attributeNumeric = []; % A x 1 logical array : is this attribute a numeric value?
        attributeAsVector = []; % A x 1 logical array : is this attribute collectible as a vector
        attributeValueListsManual = {}; % A x 1 cell array of permitted values (or cells of values) for this attribute
        attributeValueBinsManual = {}; % A x 1 cell array of value Nbins x 2 value bins to use for numeric lists
        attributeValueBinsAutoCount % A x 1 numeric array of Nbins to use when auto computing the bins, NaN if not in use
        attributeValueBinsAutoModes % A x 1 numeric array of either AttributeValueBinsAutoUniform or AttributeValueBinsAutoQuantiles

        attributeValueListsAsStringsManual = {}; % A x 1 array of cellstr which remap the attribute values with value lists

        axisValueListsManual % G x 1 cell of cells: each contains a struct specifying an attribute specification for each element along the axis
        axisValueListsOccupiedOnly % G x 1 logical indicating whether to constrain the combinatorial valueList to only occupied elements (with > 0 trials)

        axisValueListsAsStringsManual = {}; % G x 1 array of cellstr which define manual settings for axisValueListsAsStrings
        axisValueListsAsStringsShortManual = {}; % G x 1 array of cells which define manual settings for axisValueListsAsStringsShort

        axisRandomizeModes % G x 1 numeric of constants beginning with Axis* (see below)
        axisRandomizeWithReplacement % G x 1 logical indicating whether ot not to use replacement
        axisRandomizeResampleFromList % G x 1 cell of cells: one for each axis
            % for each axis, a cell whose length matches the number of
            % values for that axis, specifying which positions to draw
            % conditions from for that position
            %
            % e.g. if axis..List{1} contained {2 2}, we would be sampling along axis 1
            % from trials with valueList{2} to fill conditions at subscript 1 and 2
            %
            % e.g. if axis..List{1} contained {1 2 3}, we would be doing
            % the equivalent of axisResampleFromSame along axis 1

        isResampledWithinConditions = false; % boolean flag indicating whether to resampleFromSame the listByCondition
                      % after building it, which resamples with replacement
                      % without changing condition labels.

        randomSeed = 1;

        % scalar numeric seed initializing the RandStream which will generate shuffling or resampling along each axis
        % the persistence of this seed ensures that the randomization can reliably be repeated, but the results may change if anything
        % about any of the attributes / axes is changed.

        % see conditionIncludeMask above
        conditionIncludeMaskManual

        namesManual % conditionsSize cell array of condition names for manual specification
        namesShortManual
    end

    % END OF STORED TO DISK PROPERTIES

    properties(Hidden, Access=protected)
        odc % handle to a ConditionDescriptorOnDemandCache
    end

    % THE FOLLOWING PROPERTIES WRAP EQUIVALENT PROPERTIES IN ODC
    % on get: retrieve from odc, if empty {call build<Property>, store in odc, return it}
    % on set: make copy of odc to alleviate dependency, store in odc
    %
    % Note: we use the build<Property> methods because property getters
    % cannot be inherited, so subclasses can override the build method
    % instead.
    properties(Transient, Dependent, SetAccess=protected)
        % These are generated on the fly by property get, but cached for speed, see invalidateCache to reset them

        % these are X-dimensional objects where X is nAxes
        conditions % X-dimensional struct where values(...idx...).attribute is the value of that attribute on that condition
        conditionsAxisAttributesOnly % includes only the attributes actively selected for
        conditionsAsStrings % includes attribute values as strings rather than numeric
        conditionsAsStringsIncludingFilters

        appearances % A-dimensional struct of appearance values
        names % A-dimensional cellstr array with names of each condition
        namesShort
        namesMultiline % A-dimension cellstr array with names of each condition separated into multiple lines via \n
        namesMultilineShort % A-dimension cellstr array with names of each condition separated into multiple lines via \n

        attributeValueLists % A x 1 cell array of values allowed for this attribute
                           % here just computed from attributeValueListManual, but in ConditionInfo
                           % can be automatically computed from the data
        attributeValueListsAsStrings % same as above, but everything is a string

        axisValueLists % G dimensional cell array of structs which select attribute values for that position along an axis
        axisValueListsAsStrings % G dimensional cell array of cellstr which give names for the values along each axis (including attribute name)
        axisValueListsAsStringsShort % G dimensional cell array of cellstr which give shortened names for the values along each axis (just values)
        axisValueListModes % G dimensional array of AxisValueList* constants below indicating how axis value lists are generated
    end

    % how are attribute values determined for a given attribute?
    properties(Constant, Hidden)
        % for attributeValueListModes
        AttributeValueListManual = 1;
        AttributeValueListAuto = 2;
        AttributeValueBinsManual = 3;
        AttributeValueBinsAutoUniform = 4;
        AttributeValueBinsAutoQuantiles = 5;

        % for axisRandomizeModes
        AxisOriginal = 1; % use original axis ordering
        AxisShuffled = 2; % shuffle the labels along this axis preserving the original counts within each bin
        AxisResampledFromSpecified = 3; % resample with replacement from a different bin (see axisRandomizeResampleFromList)

        % for axisValueListModes
        AxisValueListAutoAll = 1;
        AxisValueListAutoOccupied = 2;
        AxisValueListManual = 3;
    end

    % Constructor, load, save methods
    methods
        function ci = ConditionDescriptor()
            ci.odc = ConditionDescriptorOnDemandCache();
        end
    end

    methods % General methods, setters and getters
        function ci = notifyConditionsChanged(ci)
            % when the condition tensor's shape or size changes, we need to
            % reset the condition include mask.
            % This does not include changes to condition include mask or the condition membership manual, which should
            % just call invalidateCache

            ci.warnIfNoArgOut(nargout);
            ci.conditionIncludeMaskManual = [];
            ci = ci.invalidateCache();
        end

        % flush the contents of odc as they are invalid
        % call this at the end of any methods which would want to
        % regenerate these values
        function ci = invalidateCache(ci)
            ci.warnIfNoArgOut(nargout);

            if ~isempty(ci.odc)
                ci.odc  = ci.odc.copy();
                ci.odc.flush();
            end

            % clear the conditionIncludeMask if it's no longer valid
            % no longer should need to do this, notifyConditionsChanged
            % should do this for us, but just to be sure
            if ~ci.allAxisValueListsManual
                ci.conditionIncludeMaskManual = [];
            end
        end

        function ci = invalidateNames(ci)
            ci.warnIfNoArgOut(nargout);

            % here we precompute these things to save time,
            % but each of these things also has a get method that will
            % recompute this for us
            if ~isempty(ci.odc)
                ci.odc  = ci.odc.copy();
                ci.odc.flushNames();
            end
        end

        function ci = invalidateAppearanceInfo(ci)
            ci.warnIfNoArgOut(nargout);

            if ~isempty(ci.odc)
                ci.odc  = ci.odc.copy();
                ci.odc.flushAppearanceInfo();
            end
        end

        function ci = set.nameFn(ci, fn)
            ci.nameFn = fn;
            ci = ci.invalidateCache();
        end

        function ci = set.appearanceFn(ci, fn)
            ci.appearanceFn = fn;
            ci = ci.clearAppearanceModifications();
            % only need to flush appearance info to save time
            ci = ci.invalidateAppearanceInfo();
        end

        function ci = freezeAppearances(ci)
            % cache the current condition appearances

            frozenConditions = ci.conditionsAxisAttributesOnly;
            frozenAppearances = ci.appearances;
            ci.appearanceFn = @frozenAppearanceLookup;

            function a = frozenAppearanceLookup(ci, varargin)
                a = repmat(AppearanceSpec(), ci.conditionsSize);
                [cFrozen, cNew] = matchFields(frozenConditions, ci.conditions);
                if numel(fieldnames(cFrozen)) == 0
                    warning('No attributes in common with frozen condition appearances');
                    return;
                end

                nDuplicate = 0;
                nMissing = 0;
                for i = 1:numel(a)
                    mask = arrayfun(@(frozen) isequal(cNew(i), frozen), cFrozen);
                    if nnz(mask) == 0
                        nMissing = nMissing + 1;
                        continue;
                    elseif nnz(mask) > 1
                        nDuplicate = nDuplicate + 1;
                    end

                    a(i) = frozenAppearances(find(mask, 1));
                end

                if nMissing > 0
                    warning('Unable to find frozen AppearanceSpec for %d conditions', nMissing);
                end
                if nDuplicate > 0
                    warning('Encountered multiple frozen AppearanceSpecs for %d conditions', nDuplicate);
                end
            end

            function [m1, m2] = matchFields(s1, s2)
                f1 = fieldnames(s1);
                f2 = fieldnames(s2);
                m1 = rmfield(s1, setdiff(f1, f2));
                m2 = rmfield(s2, setdiff(f2, f1));
                m2 = orderfields(m2, m1);
            end
        end

        function printDescription(ci)
            if isa(ci, 'ConditionInfo') && ci.applied %#ok<MCNPN>
                occupiedConditionsStr = sprintf(' (%d w/ trials)', nnz(ci.countByCondition)); %#ok<MCNPN>
            else
                occupiedConditionsStr = '';
            end
            if any(~ci.conditionIncludeMask)
                tcprintf('inline', '{yellow}%s: {none}%d conditions%s, {bright red}%d selected\n', ...
                    class(ci), ci.nConditions, occupiedConditionsStr, nnz(ci.conditionIncludeMask));
            else
                tcprintf('inline', '{yellow}%s: {none}%d conditions%s\n', ...
                    class(ci), ci.nConditions, occupiedConditionsStr);
            end

            tcprintf('inline', '  {bright blue}Attributes:\n');
            attrDesc = ci.generateAttributeDescriptions(true);
            for i = 1:ci.nAttributes
                tcprintf('inline', '    %s: {white}%s\n', attrDesc{i}, ...
                    tcprintfEscape(TrialDataUtilities.String.strjoin(ci.attributeValueListsAsStrings{i}, ', ')));
            end
            axisDesc = ci.generateAxisDescriptions(true);
            tcprintf('inline', '  {bright blue}Axes:\n');
            for i = 1:ci.nAxes
                tcprintf('inline', '    %s: {white}%s\n', axisDesc{i}, ...
                    tcprintfEscape(TrialDataUtilities.String.strjoin(ci.axisValueListsAsStringsShort{i}, ', ')));
            end

            nRandom = nnz(ci.axisRandomizeModes ~= ci.AxisOriginal);
            if nRandom > 0
                if nRandom == 1
                    s = 'axis';
                else
                    s = 'axes';
                end
                tcprintf('inline', '  {bright red}%d %s with randomization applied\n', nRandom, s);
            end

            if ~isempty(ci.attributeSortByList)
                tcprintf('inline', '  {bright blue}Sort: {purple}%s\n', TrialDataUtilities.String.strjoin(ci.attributeSortByList, ', '));
            end
            if ci.isResampledWithinConditions
                tcprintf('inline', '  {bright red}Randomization active: {darkGray}(seed=%g) {none}Trials resampled within conditions\n', ci.randomSeed);
            end

        end

        function printOneLineDescription(ci)
            if ci.nAxes == 0
                axisStr = 'no grouping axes';
            else
                axisStr = TrialDataUtilities.String.strjoin(ci.axisDescriptions, ' , ');
            end

            attrFilter = ci.attributeNames(ci.attributeActsAsFilter);
            if isempty(attrFilter)
                filterStr = 'no filtering';
            else
                filterStr = sprintf('filtering by %s', strjoin(attrFilter));
            end

            tcprintf('inline', '{yellow}%s: {none}%s, %s\n', ...
                class(ci), axisStr, filterStr);
        end

        function disp(ci)
            ci.printDescription();
            fprintf('\n');
            builtin('disp', ci);
        end

        function tf = get.axisValueListIsManual(ci)
            tf = ci.axisValueListModes == ci.AxisValueListManual;
        end

        function tf = get.allAxisValueListsManual(ci)
            % returns true if all axis value
            % lists are manually specified, false otherwise if anything is
            % automatically determined

            tf = all(ci.axisValueListIsManual);
        end

        function assertAllAxisValueListsManual(ci)
            assert(ci.allAxisValueListsManual, 'All axis value lists must be manual mode (fixed set of values). Use .fixAllAxisValueLists or fixValueListsByApplyingToTrialData');
        end

        function tf = get.attributeValueListIsManual(ci)
            tf = ismember(ci.attributeValueModes, [ci.AttributeValueListManual, ci.AttributeValueBinsManual]);
        end

        function tf = get.attributeValueListIsBinned(ci)
            tf = ismember(ci.attributeValueModes, [ci.AttributeValueBinsManual, ci.AttributeValueBinsAutoUniform, ci.AttributeValueBinsAutoQuantiles]);
        end
        
        function tf = get.axisValueListIsBinned(ci)
            nA = ci.nAxes;
            tf = false(nA, 1);
            attr_binned = ci.attributeValueListIsBinned;
            for iA = 1:ci.nAxes
                if numel(ci.axisAttributes{iA}) == 1
                    tf(iA) = attr_binned(ci.getAttributeIdx(ci.axisAttributes{iA}));
                end
            end
        end
                

        function tf = get.allAttributeValueListsManual(ci)
            % returns true if all attribute value lists
            % are manually specified, false otherwise if anything is
            % automatically determined

            tf = all(ci.attributeValueListIsManual);
        end

        function tf = get.allValueListsManual(ci)
            % returns true if all attribute value lists and axis value
            % lists are manually specified, false otherwise if anything is
            % automatically determined
            tf = ci.allAxisValueListsManual && ci.allAttributeValueListsManual;
        end
    end

    methods % Axis related
        function n = get.nAxes(ci)
            n = numel(ci.axisAttributes);
        end

        function a = get.attributeAlongWhichAxis(ci)
            a = nanvec(ci.nAttributes);
            for iX = 1:ci.nAxes
                a(ci.getAttributeIdx(ci.axisAttributes{iX})) = iX;
            end
        end

        function modes = get.axisValueListModes(ci)
            modes = nanvec(ci.nAxes);

            for iX = 1:ci.nAxes
                if ~isempty(ci.axisValueListsManual{iX})
                    modes(iX) = ci.AxisValueListManual;
                elseif ci.axisValueListsOccupiedOnly(iX)
                    modes(iX) = ci.AxisValueListAutoOccupied;
                else
                    modes(iX) = ci.AxisValueListAutoAll;
                end
            end
        end

        function counts = get.nValuesAlongAxes(ci)
            counts = cellfun(@numel, ci.axisValueLists);
        end

        % determine whether each attribute acts to filter valid trials
        function tf = get.attributeActsAsFilter(ci)
            modes = ci.attributeValueModes;
            tf = ismember(modes, [ci.AttributeValueListManual, ci.AttributeValueBinsManual]);
        end

        function names = get.axisNames(ci)
            names = cellvec(ci.nAxes);
            for iX = 1:ci.nAxes
                attr = ci.axisAttributes{iX};
                names{iX} = TrialDataUtilities.String.strjoin(attr, ' x ');
            end
        end

        function desc = get.axisDescriptions(ci)
            desc = ci.generateAxisDescriptions();
        end

        function str = get.randomizationDescription(ci)
            isRand = ci.axisRandomizeModes ~= ci.AxisOriginal;
            axisModeStr = cellfun(@(name, mode) sprintf('%s %s', name, mode), ...
                ci.axisNames(isRand), ci.axisRandomizeModesAsStrings(isRand), ...
                'UniformOutput', false);
            if ci.isResampledWithinConditions
                axisModeStr{end+1} = 'trials resampled within conditions';
            end
            str = TrialDataUtilities.String.strjoin(axisModeStr, ', ');
        end

        function desc = generateAxisDescriptions(ci, useColor)
            if nargin < 2
                useColor = false;
            end
            desc = cellvec(ci.nAxes);

            vlStrCell = ci.axisValueListModesAsStrings;
            randStrCell = ci.axisRandomizeModesAsStrings;
            for iX = 1:ci.nAxes
                attr = ci.axisAttributes{iX};
                nv = ci.conditionsSize(iX);
                vlStr = vlStrCell{iX};
                if strcmp(vlStr, 'manual')
                    filterStr = ' filter';
                else
                    filterStr = '';
                end
                randStr = randStrCell{iX};
                if ~isempty(vlStr)
                    vlStr = [' ' vlStr]; %#ok<AGROW>
                end
                if ~isempty(randStr)
                    randStr = [' ' randStr]; %#ok<AGROW>
                end
                if useColor
                    desc{iX} = sprintf('{purple}%s {darkGray}(%d%s{bright red}%s%s{darkGray})', ...
                        TrialDataUtilities.String.strjoin(attr, ' x '), nv, vlStr, filterStr, randStr);
                else
                    desc{iX} = sprintf('%s (%d%s%s)', ...
                        TrialDataUtilities.String.strjoin(attr, ' x '), nv, vlStr, randStr);
                end
            end
        end

        function strCell = get.axisValueListModesAsStrings(ci)
            strCell = cellvec(ci.nAxes);
            for iX = 1:ci.nAxes
                switch ci.axisValueListModes(iX)
                    case ci.AxisValueListAutoAll
                        vlStr = 'auto';
                    case ci.AxisValueListAutoOccupied
                        vlStr = 'autoOccupied';
                    case ci.AxisValueListManual
                        vlStr = 'manual';
                    otherwise
                        error('Unknown axisValueListMode for axis %d', iX);
                end
                strCell{iX} = vlStr;
            end
        end

        function strCell = get.axisRandomizeModesAsStrings(ci)
            strCell = cellvec(ci.nAxes);
            for iX = 1:ci.nAxes
                if ci.axisRandomizeWithReplacement(iX)
                    replaceStr = 'WithReplacement';
                else
                    replaceStr = '';
                end
                switch ci.axisRandomizeModes(iX)
                    case ci.AxisOriginal
                        randStr = '';
                    case ci.AxisShuffled
                        randStr = ['shuffled' replaceStr];
                    case ci.AxisResampledFromSpecified
                        randStr = ['resampled' replaceStr];
                    otherwise
                        error('Unknown axisRandomizeMode for axis %d', iX);
                end
                strCell{iX} = randStr;
            end
        end

        function ci = addAxis(ci, varargin)
            ci.warnIfNoArgOut(nargout);

            p = inputParser;
            p.addOptional('attributes', {}, @(x) ischar(x) || iscellstr(x) || isstring(x));
            p.addParameter('name', '', @ischar);
            p.addParameter('valueList', {}, @(x) true);
            p.parse(varargin{:});

            if ~iscell(p.Results.attributes)
                attr = cellstr(p.Results.attributes);
            else
                attr = p.Results.attributes;
            end
            ci.assertHasAttribute(attr);
            attr = unique(attr, 'stable');
            ci = ci.removeAttributesFromAxes(attr);

            valueList = p.Results.valueList;
            if ~isempty(valueList) && ~isstruct(valueList)
                assert(numel(attr) == 1, 'Must specify valueList as struct for multi-attribute axes');
                for iV = 1:numel(valueList)
                    if iscell(valueList)
                        val = valueList{iV};
                    else
                        val = valueList(iV);
                    end
                    valueStruct(iV).(attr{1}) = val; %#ok<AGROW>
                end
                valueList = valueStruct;
            end

            % create a grouping axis
            idx = ci.nAxes + 1;
            ci.axisAttributes{idx} = makecol(attr);
            ci.axisAttributes = makecol(ci.axisAttributes);
            ci.axisValueListsManual{idx} = valueList;
            ci.axisValueListsAsStringsManual{idx} = {};
            ci.axisValueListsAsStringsManual{idx} = {};
            ci.axisValueListsAsStringsShortManual{idx} = {};
            ci.axisRandomizeModes(idx) = ci.AxisOriginal;
            ci.axisRandomizeWithReplacement(idx) = false;
            ci.axisRandomizeResampleFromList{idx} = [];

            valueListMode = ci.getAttributeValueListMode(attr);
            if all(ismember(valueListMode, [ci.AttributeValueListAuto, ci.AttributeValueBinsAutoUniform,  ci.AttributeValueBinsAutoQuantiles]))
                % all attributes are auto, make the axis auto too
                ci.axisValueListsOccupiedOnly(idx) = true;
            else
                % some attributes have been manually specified, so make the
                % axis default to auto all
                ci.axisValueListsOccupiedOnly(idx) = false;
            end
            ci = ci.notifyConditionsChanged();
        end

        function ci = replaceAxis(ci, idx, varargin)
            ci.warnIfNoArgOut(nargout);

            p = inputParser;
            p.addOptional('attributes', {}, @(x) ischar(x) || iscellstr(x));
            p.addParameter('name', '', @ischar);
            p.addParameter('valueList', {}, @(x) true);
            p.parse(varargin{:});

            if ~iscell(p.Results.attributes)
                attr = {p.Results.attributes};
            else
                attr = p.Results.attributes;
            end
            ci.assertHasAttribute(attr);
            attr = unique(attr, 'stable');

            ci = ci.removeAttributesFromAxes(attr, 'ignoreAxes', idx);

            valueList = p.Results.valueList;
            if ~isempty(valueList) && ~isstruct(valueList)
                assert(numel(attr) == 1, 'Must specify valueList as struct for multi-attribute axes');
                for iV = 1:numel(valueList)
                    if iscell(valueList)
                        val = valueList{iV};
                    else
                        val = valueList(iV);
                    end
                    valueStruct(iV).(attr{1}) = val; %#ok<AGROW>
                end
                valueList = valueStruct;
            end

            % create a grouping axis
            ci.axisAttributes{idx} = makecol(attr);
            ci.axisValueListsManual{idx} = valueList;
            ci.axisValueListsAsStringsManual{idx} = {};
            ci.axisValueListsAsStringsManual{idx} = {};
            ci.axisValueListsAsStringsShortManual{idx} = {};
            ci.axisRandomizeModes(idx) = ci.AxisOriginal;
            ci.axisRandomizeWithReplacement(idx) = false;
            ci.axisRandomizeResampleFromList{idx} = [];

            valueListMode = ci.getAttributeValueListMode(attr);
            if all(ismember(valueListMode, [ci.AttributeValueListAuto, ci.AttributeValueBinsAutoUniform,  ci.AttributeValueBinsAutoQuantiles]))
                % all attributes are auto, make the axis auto too
                ci.axisValueListsOccupiedOnly(idx) = true;
            else
                % some attributes have been manually specified, so make the
                % axis default to auto all
                ci.axisValueListsOccupiedOnly(idx) = false;
            end
            ci = ci.notifyConditionsChanged();
        end

        function ci = maskAxes(ci, mask)
            ci.warnIfNoArgOut(nargout);

            ci.axisAttributes = makecol(ci.axisAttributes(mask));
            ci.axisValueListsManual = ci.axisValueListsManual(mask);
            ci.axisValueListsAsStringsManual = ci.axisValueListsAsStringsShortManual(mask);
            ci.axisValueListsAsStringsShortManual = ci.axisValueListsAsStringsShortManual(mask);
            ci.axisRandomizeModes = ci.axisRandomizeModes(mask);
            ci.axisRandomizeWithReplacement = ci.axisRandomizeWithReplacement(mask);
            ci.axisRandomizeResampleFromList = ci.axisRandomizeResampleFromList(mask);
            ci.axisValueListsOccupiedOnly = ci.axisValueListsOccupiedOnly(mask);

            ci = ci.notifyConditionsChanged();
        end

        function ci = permuteAxes(ci, mask)
            ci = ci.maskAxes(mask);
        end

        function ci = transposeAxes(ci)
            ci.warnIfNoArgOut(nargout);
            assert(ci.nAxes == 2, 'ConditionDescriptor must have 2 axes for transpose');
            ci = ci.permuteAxes([2 1]);
        end

        function ci = removeAxis(ci, axisSpec)
            aIdx = ci.axisLookupByAttributes(axisSpec);
            mask = ~TensorUtils.vectorIndicesToMask(aIdx, ci.nAxes);
            ci = ci.maskAxes(mask);
        end

        % wipe out existing axes and creates simple auto axes along each
        function ci = groupBy(ci, varargin)
            ci.warnIfNoArgOut(nargout);
            ci = ci.clearAxes();

            for i = 1:numel(varargin)
                ci = ci.addAxis(varargin{i});
            end
        end

        function ci = groupByAll(ci)
            ci.warnIfNoArgOut(nargout);
            ci = ci.groupBy(ci.attributeNames{:});
        end

        % remove all axes
        function ci = clearAxes(ci)
            ci.warnIfNoArgOut(nargout);

            ci = ci.maskAxes([]);

            ci = ci.notifyConditionsChanged();
        end

        function ci = removeAttributesFromAxes(ci, namesOrIdx, varargin)
            p = inputParser();
            p.addParameter('ignoreAxes', [], @(x) isvector(x)); % added for replaceAxis
            p.parse(varargin{:});

            ignoreAxes = TensorUtils.vectorIndicesToMask(p.Results.ignoreAxes, ci.nAxes);

            ci.warnIfNoArgOut(nargout);
            attrIdx = ci.getAttributeIdx(namesOrIdx);
            attrNames = ci.attributeNames(attrIdx);

            if ci.nAxes == 0
                return;
            end

            whichAxis = ci.attributeAlongWhichAxis;
            removeAxisMask = falsevec(ci.nAxes);
            for iAI = 1:numel(attrIdx)
                iA = attrIdx(iAI);
                iX = whichAxis(iA);
                if isnan(iX) || ignoreAxes(iX)
                    continue;
                end

                % remove this attribute from axis iX
                if ci.axisRandomizeModes(iX) ~= ci.AxisOriginal
                    error('Cowardly refusing to remove attributes from axis with randomization applied');
                end
                if ci.axisValueListModes(iX) == ci.AxisValueListManual
                    error('Cowardly refusing to remove attributes from axis with manual value list specified');
                end

                maskInAxis = strcmp(ci.axisAttributes{iX}, attrNames{iAI});
                if all(maskInAxis)
                    removeAxisMask(iX) = true;
                else
                    ci.axisAttributes{iX} = makecol(ci.axisAttributes{iX}(~maskInAxis));
                    % clear out manual value list as it's likely invalid now
                    ci.axisValueListsManual{iX} = [];
                    ci.axisValueListsAsStringsManual{iX} = {};
                    ci.axisValueListsAsStringsShortManual{iX} = {};
                    % and reset the randomization
                    ci.axisRandomizeModes(iX) = ci.AxisOriginal;
                end
            end

            ci = ci.maskAxes(~removeAxisMask);
        end

        function ci = setAxisValueList(ci, axisSpec, valueList, varargin)
            p = inputParser();
            p.addParameter('asStrings', {}, @iscellstr);
            p.addParameter('asStringsShort', {}, @iscellstr);
            p.parse(varargin{:});

            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(axisSpec);

            if numel(idx) == 1 && numel(ci.axisAttributes{idx}) == 1
                if isvector(valueList) && ~isstruct(valueList) && ~iscell(valueList)
                    valueList = num2cell(valueList);
                end
                
                if ismatrix(valueList) && size(valueList, 2) == 2 && ci.axisValueListIsBinned(idx)
                    % matrix of bins, split by rows
                    valueList = mat2cell(valueList, ones(size(valueList, 1), 1),  2);
                end
                
                if iscell(valueList) && ~isstruct(valueList{1})
                    % for one axis with single attribute, valueList can simply be a cell
                    % array of values
                    %debug('Auto converting value list for single attribute axis\n');
                    valueCell = valueList;
                    if ~iscell(valueCell), valueCell = num2cell(valueCell); end
                    valueList = makecol(struct(ci.axisAttributes{idx}{1}, valueCell));
                end
            end

            assert(isstruct(valueList) && ismatrix(valueList) && size(valueList, 2) <= 2, ....
                'Value list must be a struct vector');
            assert(isempty(setxor(fieldnames(valueList), ci.axisAttributes{idx})), ...
                'Value list fields must match axis attributes');
            ci.axisValueListsManual{idx} = valueList;
            ci.axisValueListsAsStringsManual{idx} = p.Results.asStrings;
            % if strings short not specified, use asStrings instead
            if isempty(p.Results.asStringsShort) && ~isempty(p.Results.asStrings)
                ci.axisValueListsAsStringsShortManual{idx} = p.Results.asStrings;
            else
                ci.axisValueListsAsStringsShortManual{idx} = p.Results.asStringsShort;
            end

            ci = ci.notifyConditionsChanged();
        end

        function ci = setAxisValueListDisplayAs(ci, axisSpec, strCell)
            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(axisSpec);
            assert(isscalar(idx));

            assert(ci.axisValueListIsManual(idx), 'You must call setAxisValueList to make this value list manual first');

            N = numel(ci.axisValueLists{idx});
            assert(numel(strCell) == N);

            ci.axisValueListsAsStringsManual{idx} = strCell;
            if isempty(ci.axisValueListsAsStringsShortManual{idx})
                % also set the axisValueListAsStringsShort if not already
                % specified
                ci.axisValueListsAsStringsShortManual{idx} = strCell;
            end

            ci = ci.invalidateNames();
        end

        function ci = setAxisValueListDisplayAsShort(ci, axisSpec, strCell)
            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(axisSpec);
            assert(isscalar(idx));

            assert(ci.axisValueListIsManual(idx), 'You must call setAxisValueList to make this value list manual first');

            N = numel(ci.axisValueLists{idx});
            assert(numel(strCell) == N);

            ci.axisValueListsAsStringsShortManual{idx} = strCell;

            ci = ci.invalidateNames();
        end

        function ci = setConditionNames(ci, names, namesShort)
            ci.warnIfNoArgOut(nargout);

            assert(iscellstr(names) && TensorUtils.compareSizeVectors(size(names), ci.conditionsSize), 'Names must be cellstr with conditionsSize');
            if nargin < 3
                namesShort = names;
            end

            ci.namesManual = names;
            ci.namesShortManual = namesShort;
            ci = ci.invalidateNames();
        end

        function ci = fixAxisValueList(ci, axisSpec)
            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(axisSpec);
            for i = 1:numel(idx)
                ci = ci.setAxisValueList(idx(i), ci.axisValueLists{idx(i)});
            end
        end

        function ci = fixAllAxisValueLists(ci)
            ci.warnIfNoArgOut(nargout);
            for iA = 1:ci.nAxes
                ci = ci.fixAxisValueList(iA);
            end
        end

        function valueList = getAxisValueList(ci, axisSpec)
            idx = ci.axisLookupByAttributes(axisSpec);
            valueList = makecol(ci.axisValueLists{idx});
        end

        function ci = setAllAxisValueListsAutoAll(ci)
            ci.warnIfNoArgOut(nargout);
            for idx = 1:ci.nAxes
                ci.axisValueListsManual(idx) = {[]};
                ci.axisValueListsAsStringsManual{idx} = {};
                ci.axisValueListsAsStringsShortManual{idx} = {};
                ci.axisValueListsOccupiedOnly(idx) = false;
            end
            ci = ci.notifyConditionsChanged();
        end

        function ci = setAxisValueListAutoAll(ci, axisSpec)
            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(axisSpec);

            ci.axisValueListsManual{idx} = {};
            ci.axisValueListsAsStringsManual{idx} = {};
            ci.axisValueListsAsStringsShortManual{idx} = {};
            ci.axisValueListsOccupiedOnly(idx) = false;
            ci = ci.notifyConditionsChanged();
        end

        function ci = setAxisValueListAutoOccupied(ci, axisSpec)
            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(axisSpec);

            ci.axisValueListsManual{idx} = {};
            ci.axisValueListsAsStringsManual{idx} = {};
            ci.axisValueListsAsStringsShortManual{idx} = {};
            ci.axisValueListsOccupiedOnly(idx) = true;

            ci = ci.notifyConditionsChanged();
        end

        function nv = get.conditionsSize(ci)
            nv = TensorUtils.expandSizeToNDims(size(ci.conditions), ci.nAxes);
        end

        function nv = get.conditionsSizeNoExpand(ci)
            % ensure nv has the same length as ci.nAxes
            if ci.nAxes <= 1
                nv = size(ci.conditions, 1);
            else
                nv = TensorUtils.expandSizeToNDims(size(ci.conditions), ci.nAxes);
            end
        end

        function linearInds = get.conditionsAsLinearInds(ci)
            linearInds = TensorUtils.containingLinearInds(ci.conditionsSize);
        end

        function n = get.nConditions(ci)
            n = prod(ci.conditionsSize);
        end

        function cmap = get.conditionColors(ci)
            cmap = cat(1, ci.appearances.Color);
        end

        % lookup axis idx by attribute char or cellstr, or cell of attribute cellstr
        % if a numeric indices are passed in, returns them through.
        % if not found, throws an error
        % useful for accepting either axis idx or attributes in methods
        function idx = axisLookupByAttributes(ci, attr)
            if isnumeric(attr)
                assert(all(attr >= 1 & attr <= ci.nAxes), 'Axis index out of range');
                idx = attr;
                return;
            end

            if ischar(attr)
                attr = {attr};
            end
            if iscellstr(attr)
                attr = {attr};
            end
            for iAttr = 1:numel(attr)
                if ~iscell(attr{iAttr})
                    attr{iAttr} = attr(iAttr);
                end
            end

            % attr is a cell of cellstr of attributes, and axisAttributes is a cell
            % of such cellstr (the attributes along each axis).
            % Consequently, we're looking for an EXACT match between attr
            % and an axis
            idx = nanvec(numel(attr));
            for iAttr = 1:numel(attr)
                for i = 1:ci.nAxes
                    if isempty(setxor(attr{iAttr}, ci.axisAttributes{i}))
                        idx(iAttr) = i;
                        break;
                    end
                end

                assert(~isnan(idx(iAttr)), 'Axis with attributes %s not found', ...
                    TrialDataUtilities.String.strjoin(attr{iAttr}, ' x '));
            end

        end

        function ci = setConditionIncludeMask(ci, mask)
            ci.warnIfNoArgOut(nargout);
            mask = TensorUtils.vectorIndicesToMask(mask, ci.nConditions);
            assert(islogical(mask) && numel(mask) == ci.nConditions, 'conditionIncludeMask must be nConditions x 1 logical vector');
            ci.assertAllAxisValueListsManual();
            ci.conditionIncludeMaskManual = makecol(mask(:));
            ci = ci.invalidateCache();
        end

        function ci = resetConditionIncludeMask(ci)
            ci.warnIfNoArgOut(nargout);
            ci.conditionIncludeMaskManual = [];
            ci = ci.invalidateCache();
        end

        function v = get.conditionIncludeMask(ci)
            if ~isempty(ci.conditionIncludeMaskManual) && ci.allAxisValueListsManual && ...
               numel(ci.conditionIncludeMaskManual) == ci.nConditions
                v = ci.conditionIncludeMaskManual;
            else
                v = truevec(ci.nConditions);
            end
        end
    end

    methods % Axis randomization related
        function tf = get.hasRandomization(ci)
            tf = any(ci.axisRandomizeModes ~= ci.AxisOriginal) || ci.isResampledWithinConditions;
        end

        function ci = setRandomSeed(ci, seed)
            ci.warnIfNoArgOut(nargout);
            ci.randomSeed = seed;
        end

        function ci = newRandomSeed(ci)
            ci.warnIfNoArgOut(nargout);
            ci = ci.setRandomSeed(RandStream.shuffleSeed());
        end

        function ci = newRandomSeedIfEmpty(ci)
            ci.warnIfNoArgOut(nargout);
            if isempty(ci.randomSeed)
                warning('Automatically selecting random seed. Call .setRandomSeed(seed) for deterministic resuls');
                ci = ci.newRandomSeed();
            end
        end

        function seedRandStream(ci, seed)
            if nargin < 2
                seed = ci.randomSeed;
            end

            s = RandStream('mt19937ar', 'Seed', seed);
            RandStream.setGlobalStream(s);
        end

        function ci = noRandomization(ci)
            ci.warnIfNoArgOut(nargout);
            ci.isResampledWithinConditions = false;
            for i = 1:ci.nAxes
                ci = ci.axisNoRandomization(i);
            end
        end

        function ci = resampleTrialsWithinConditions(ci)
            ci.warnIfNoArgOut(nargout);
            ci = ci.newRandomSeedIfEmpty();
            ci.isResampledWithinConditions = true;
            ci = ci.invalidateCache();
        end

        function ci = axisNoRandomization(ci, idxOrAttr)
            ci.warnIfNoArgOut(nargout);
            idx = ci.axisLookupByAttributes(idxOrAttr);
            ci.axisRandomizeModes(idx) = ci.AxisOriginal;
            ci.axisRandomizeResampleFromList{idx} = [];
            ci.axisRandomizeWithReplacement(idx) = false;
            ci = ci.invalidateCache();
        end

        function ci = axisShuffle(ci, idxOrAttr, replace)
            ci.warnIfNoArgOut(nargout);
            if nargin < 3
                replace = false;
            end

            ci = ci.newRandomSeedIfEmpty();
            idx = ci.axisLookupByAttributes(idxOrAttr);
            ci.axisRandomizeModes(idx) = ci.AxisShuffled;
            ci.axisRandomizeResampleFromList{idx} = [];
            ci.axisRandomizeWithReplacement(idx) = replace;
            ci = ci.invalidateCache();
        end

        function ci = axisResampleFromSpecifiedValueListIndices(ci, axisIdxOrAttr, resampleFromList, replace)
            ci.warnIfNoArgOut(nargout);
            if nargin < 4
                replace = false;
            end
            ci = ci.newRandomSeedIfEmpty();
            idx = ci.axisLookupByAttributes(axisIdxOrAttr);
            assert(isscalar(idx), 'Method operates on only one axis');

            nValues = ci.nValuesAlongAxes(idx);
            if isscalar(resampleFromList)
                % all resampling from same, clone to length of axis
                resampleFromList = repmat(resampleFromList, nValues, 1);
            end

            assert(numel(resampleFromList) == nValues, 'Resample from list must match number of values along axis');

            if ~iscell(resampleFromList)
                % convert to cell array
                resampleFromList = num2cell(resampleFromList);
            end

            % replace each list of numeric indices with struct match
            % templates
            axisValueList = ci.axisValueLists{idx};
            for i = 1:nValues
                resampleFromList{i} = axisValueList(resampleFromList{i});
            end

            ci.axisRandomizeModes(idx) = ci.AxisResampledFromSpecified;
            ci.axisRandomizeResampleFromList{idx} = resampleFromList;
            ci.axisRandomizeWithReplacement(idx) = replace;

            ci = ci.invalidateCache();
        end

        function ci = axisResampleFromSpecifiedValues(ci, axisIdxOrAttr, resampleFromList, replace)
            % resampleFromList specifies a set of value specifiers
            ci.warnIfNoArgOut(nargout);
            if nargin < 4
                replace = false;
            end
            ci = ci.newRandomSeedIfEmpty();
            aIdx = ci.axisLookupByAttributes(axisIdxOrAttr);
            assert(isscalar(aIdx), 'Method operates on only one axis');

            nValues = ci.nValuesAlongAxes(aIdx);
            if ischar(resampleFromList)
                resampleFromList = repmat({resampleFromList}, nValues, 1);
            elseif isscalar(resampleFromList)
                % all resampling from same, clone scalar value to to length of axis
                resampleFromList = repmat(resampleFromList, nValues, 1);
            end

            if ~isstruct(resampleFromList) && ~iscell(resampleFromList)
                % values specified as numbers, okay if single attribute,
                % convert to struct array with single attribute as the
                % field name
                nAttr = numel(ci.axisAttributes{aIdx});
                assert(nAttr == 1, 'Must specify values as struct for multi-attribute axes');
                resampleFromList = struct(ci.axisAttributes{aIdx}{1}, num2cell(resampleFromList));
            end

            assert(numel(resampleFromList) == nValues, 'Resample from list must match number of values along axis');

            if iscell(resampleFromList)
                nAttr = numel(ci.axisAttributes{aIdx});
                list = resampleFromList;
                for i = 1:numel(list)
                    if ~isstruct(list{i})
                        assert(nAttr == 1, 'Must specify values as struct for multi-attribute axes');
                        if ischar(list{i}) || iscell(list{i})
                            resampleFromList{i} = struct(ci.axisAttributes{aIdx}{1}, list{i});
                        else
                            resampleFromList{i} = struct(ci.axisAttributes{aIdx}{1}, num2cell(list{i}));
                        end
                    end
                end
            end

            if isstruct(resampleFromList)
                % split struct array into separate cells
                resampleFromList = num2cell(resampleFromList);
            end

%             % lookup each struct in the axis value list to convert to a
%             % subscript for storage
%             idxList = cellvec(nValues);
%             for iC = 1:nValues
%                 idxList{iC} = ci.axisLookupValueInValueList(aIdx, resampleFromList{iC});
%             end

            ci.axisRandomizeModes(aIdx) = ci.AxisResampledFromSpecified;
            ci.axisRandomizeResampleFromList{aIdx} = resampleFromList;
            ci.axisRandomizeWithReplacement(aIdx) = replace;

            ci = ci.invalidateCache();
        end
    end

    methods % Axis permutation and reshaping
        function ci = reshapeAxes(ci, varargin)
            % reshape the conditions tensor by permuting and combining axes
            % successive arguments are either scalars or vectors of scalars
            % which index into axes numerically, or strings, cellstrings, or cell
            % arrays of cellstrings which index into axes by attribute contents
            ci.warnIfNoArgOut(nargout);
            nArgs = numel(varargin);
            newValueListModes = nan(nArgs, 1);
            [newAxisAttributes, newAxisValueListsManual] = deal(cell(nArgs, 1));

            foundWildcard = false;
            idxByArg = cell(nArgs, 1);
            for iArg = 1:nArgs
                % lookup which axes this arg refers to
                arg = varargin{iArg};
                if isempty(arg)
                    idx = []; % refers to no-axes and will be a singleton dimension
                elseif ischar(arg)
                    % '*' matches remaining axes, compute this after first
                    % pass is finished
                    if strcmp(arg, '*')
                        if foundWildcard > 0
                            error('Cannot specify multiple ''*'' wildcard matches');
                        else
                            foundWildcard = iArg;
                            idx = [];
                        end
                    else
                        idx = ci.axisLookupByAttributes(arg);
                    end
                elseif isscalar(arg) || isnumeric(arg)
                    idx = arg;
                elseif iscellstr(arg)
                    idx = ci.axisLookupByAttributes(arg);
                elseif iscell(arg)
                    idx = cellfun(@ci.axisLookupByAttributes, arg);
                else
                    error('Unknown argument specification');
                end

                idxByArg{iArg} = makecol(idx);
            end

            % now compute wildcard matches
            if foundWildcard > 0
                allIdx = cat(1, idxByArg{:});
                remaining = setdiff(1:ci.nAxes, allIdx);
                idxByArg{foundWildcard} = remaining;
            end

            for iArg = 1:nArgs
                idx = idxByArg{iArg};

                if isempty(idx)
                    % empty singleton axis
                    newAxisAttributes{iArg} = {};
                    newValueListModes(iArg) = ci.AxisValueListAutoAll;
                else
                    newAxisAttributes{iArg} = cat(1, ci.axisAttributes{idx});

                    % determine new axis value mode and build manual lists if
                    % necessary
                    isManual = ci.axisValueListModes(idx) == ci.AxisValueListManual;
                    isAutoOccupied = all(ci.axisValueListModes(idx) == ConditionDescriptor.AxisValueListAutoOccupied);

                    if any(isManual)
                        % at least one axis has a manual value list
                        if ~all(isManual)
                            % some are fixed, some are auto, must be an applied
                            % ConditionInfo
                            if isa(ci, 'ConditionInfo') && ci.applied
                                % possible to fix the value list of the others
                                % ci = ci.fixAxisValueList(idx);

                            else
                                error('Cannot determine axis value lists when some are automatic and some are manual and not yet applied to TrialData. Use fixAxisValueList or setAxisValueList to convert the appropriate axis value lists to manual');
                            end
                        end

                        % all are now manual
                        % build combinatorial value list including the
                        % all axes along this
                        newValueListModes(iArg) = ci.AxisValueListManual;
                        newAxisValueListsManual{iArg} = ...
                            TensorUtils.flatten(TensorUtils.buildCombinatorialStructTensor(ci.axisValueLists{idx}));
                    else
                        % all are automatic
                        if isAutoOccupied
                            % preserve auto-occupied
                            newValueListModes(iArg) = ci.AxisValueListAutoOccupied;
                        else
                            newValueListModes(iArg) = ci.AxisValueListAutoAll;
                        end
                    end
                end
            end

            % install the new axes
            ci = ci.clearAxes();
            for iArg = 1:nArgs
                ci = ci.addAxis(newAxisAttributes{iArg});
                switch newValueListModes(iArg)
                    case ci.AxisValueListManual
                        ci = ci.setAxisValueList(iArg, newAxisValueListsManual{iArg});
%                         ci.axisValueListsManual{iArg} = newAxisValueListsManual{iArg};
                    case ci.AxisValueListAutoAll
                        ci = ci.setAxisValueListAutoAll(iArg);
                    case ci.AxisValueListAutoOccupied
                        ci = ci.setAxisValueListAutoOccupied(iArg);
                end
            end
            ci = ci.notifyConditionsChanged();
        end

        function ci = flattenAxes(ci)
            % combine all axes into one, going from an nAxes-dimensional conditions
            % tensor to a long vector of conditions
            ci.warnIfNoArgOut(nargout);
            ci = ci.reshapeAxes(1:ci.nAxes);
        end

        function ci = flattenAxesExceptFirst(ci)
            % combine all axes 2:end into one, going from an nAxes-dimensional conditions
            % tensor to a size(conditions, 1) x N matrix of conditions
            ci.warnIfNoArgOut(nargout);
            if ci.nAxes > 1
                ci = ci.reshapeAxes(1, 2:ci.nAxes);
            end
        end

        function [ci, maskC] = selectConditions(ci, mask)
            % select specific conditions by linear index or mask
            % and return a single-axis condition descriptor with just those
            % conditions selected
            ci.warnIfNoArgOut(nargout);
            idx = ci.conditionsAsLinearInds(mask);
            attr = ci.attributeNames(~isnan(ci.attributeAlongWhichAxis));
            valList = ci.conditionsAxisAttributesOnly;
            valList = valList(idx);

            maskC = TensorUtils.vectorIndicesToMask(mask, ci.nConditions);

            ci = ci.clearAxes();
            ci = ci.addAxis(attr, 'valueList', valList);
        end

        function [ci, maskC] = selectConditionsAlongAxis(ci, axisAttr, mask)
            % select specific conditions along an axis specified by
            % axisAttr. mask can be a logical or linear mask.
            %
            % maskC is the mask into .conditions that indicates which
            % conditions will be kept.
            ci.warnIfNoArgOut(nargout);
            aIdx = ci.axisLookupByAttributes(axisAttr);
            valList = ci.axisValueLists{aIdx};
            valList = valList(mask);

            % compute this before changing conditions
            if nargout > 1
                maskC = TensorUtils.maskSelectAlongDimension(ci.conditionsSize, aIdx, mask);
            end

            ci = ci.setAxisValueList(aIdx, valList);
        end

        function [ci, maskC] = matchSelectConditionsAlongAxis(ci, axisAttr, match)
            % select specific conditions along an axis specified by
            % axisAttr. match can be a struct which matches against the
            % conditions or an array of values for axes with only one
            % attribute
            ci.warnIfNoArgOut(nargout);
            aIdx = ci.axisLookupByAttributes(axisAttr);
            valList = ci.axisValueLists{aIdx};

            [~, mask] = ci.axisLookupValueInValueList(aIdx, match);

            % do this before changing conditions
            if nargout > 1
                maskC = TensorUtils.maskSelectAlongDimension(ci.conditionsSize, aIdx, mask);
            end

            valList = valList(mask);
            ci = ci.setAxisValueList(aIdx, valList);

        end

        function [idx, mask] = axisLookupValueInValueList(ci, axisAttr, match)
            % find a specific attribute value or set of attribute values
            % (specified as a struct) along a specific axis. if match is a
            % struct array, the union of all matches is taken. unspecified
            % fields will act as wildcards, matching all possible values
            % taken along the axis
            aIdx = ci.axisLookupByAttributes(axisAttr);
            valList = ci.axisValueLists{aIdx};

            nAttr = numel(ci.axisAttributes{aIdx});
            if ~isstruct(match)
                assert(nAttr == 1, 'Must specify struct array to match against when multiple attributes on axis');

                % for single attribute axes, convert to a match struct to
                % make the search the same as for multi-attribute axes
                if ~iscell(match)
                    if ischar(match)
                        match = {match};
                    elseif isnumeric(match)
                        match = num2cell(match);
                    else
                        error('Unknown match class');
                    end
                end
                match = struct(ci.axisAttributes{aIdx}{1}, match);
            end

            % remove the irrelevant (unspecified in match) fields from
            % valueList
            valListMatch = rmfield(valList, setdiff(fieldnames(valList), fieldnames(match)));
            % match the struct in the value list
            % if match is an array, the union of values matched by each
            mask = false(numel(valList), 1);
            for c = 1:numel(valListMatch)
                for v = 1:numel(match)
                    if isequal(match(v), valListMatch(c))
                        mask(v) = true;
                        break;
                    end
                end
            end

            idx = find(mask);
        end
    end

    methods % Appearance modification fn
        function ci = clearAppearanceModifications(ci)
            ci.warnIfNoArgOut(nargout);
            ci.appearanceColorByAttributesList = [];
            ci.appearanceColorByAttributesCmap = [];
            ci.appearanceColorByAxesList = [];
            ci.appearanceColorByAxesCmap = [];

            ci.appearanceLineStyleByAxesList = [];
            ci.appearanceLineStyleByAxesMap = [];
            ci.appearanceLineStyleByAxesList = [];
            ci.appearanceLineStyleByAxesMap = [];

            ci.appearanceLineWidthByAttributesList = [];
            ci.appearanceLineWidthByAttributesMap = [];
            ci.appearanceLineWidthByAxesList = [];
            ci.appearanceLineWidthByAxesMap = [];

            ci = ci.invalidateAppearanceInfo();
        end

        function ci = colorByAttributes(ci, attributes, varargin)
            p = inputParser();
            p.addOptional('cmapFn', @TrialDataUtilities.Colormaps.linspecer, ...
                @(x) ismatrix(x) || isa(x, 'function_handle'));
            p.parse(varargin{:});

            ci.appearanceColorByAxesList = [];
            ci.appearanceColorByAxesCmap = [];

            ci.warnIfNoArgOut(nargout);
            if ~iscell(attributes), attributes = {attributes}; end
            ci.appearanceColorByAttributesList = attributes;
            ci.appearanceColorByAttributesCmap = p.Results.cmapFn;
            ci = ci.invalidateAppearanceInfo();
        end

        function ci = colorByAxes(ci, axesSpec, varargin)
            p = inputParser();
            p.addOptional('cmapFn', @TrialDataUtilities.Colormaps.linspecer, ...
                @(x) ismatrix(x) || isa(x, 'function_handle'));
            p.parse(varargin{:});

            ci.warnIfNoArgOut(nargout);
            ci.axisLookupByAttributes(axesSpec);

            ci.appearanceColorByAttributesList = [];
            ci.appearanceColorByAttributesCmap = [];

            % want list to be cell of cellstr
            if ~iscell(axesSpec), axesSpec = {axesSpec}; end
            if iscellstr(axesSpec), axesSpec = {axesSpec}; end
            ci.appearanceColorByAxesList = axesSpec;
            ci.appearanceColorByAxesCmap = p.Results.cmapFn;
            ci = ci.invalidateAppearanceInfo();
        end

        function ci = lineStyleByAttributes(ci, attributes, varargin)
            p = inputParser();
            p.addOptional('styleFn', @TrialDataUtilities.Appearance.listLineStyles, ...
                @(x) iscellstr(x) || isa(x, 'function_handle'));
            p.parse(varargin{:});

            ci.appearanceLineStyleByAxesList = [];
            ci.appearanceLineStyleByAxesMap = [];

            ci.warnIfNoArgOut(nargout);
            if ~iscell(attributes), attributes = {attributes}; end
            ci.appearanceLineStyleByAttributesList = attributes;
            ci.appearanceLineStyleByAttributesMap = p.Results.styleFn;
            ci = ci.invalidateAppearanceInfo();
        end

        function ci = lineStyleByAxes(ci, axesSpec, varargin)
            p = inputParser();
            p.addOptional('styleFn', @TrialDataUtilities.Appearance.listLineStyles, ...
                @(x) iscellstr(x) || isa(x, 'function_handle'));
            p.parse(varargin{:});

            ci.warnIfNoArgOut(nargout);
            ci.axisLookupByAttributes(axesSpec);

            ci.appearanceLineStyleByAttributesList = [];
            ci.appearanceLineStyleByAttributesMap = [];

            % want list to be cell of cellstr
            if ~iscell(axesSpec), axesSpec = {axesSpec}; end
            if iscellstr(axesSpec), axesSpec = {axesSpec}; end
            ci.appearanceLineStyleByAxesList = axesSpec;
            ci.appearanceLineStyleByAxesMap = p.Results.styleFn;
            ci = ci.invalidateAppearanceInfo();
        end

        function ci = lineWidthByAttributes(ci, attributes, varargin)
            p = inputParser();
            p.addOptional('widthFn', @(n) (1:n)', ...
                @(x) isvector(x) || isa(x, 'function_handle'));
            p.parse(varargin{:});

            ci.appearanceLineWidthByAxesList = [];
            ci.appearanceLineWidthByAxesMap = [];

            ci.warnIfNoArgOut(nargout);
            if ~iscell(attributes), attributes = {attributes}; end
            ci.appearanceLineWidthByAttributesList = attributes;
            ci.appearanceLineWidthByAttributesMap = p.Results.widthFn;
            ci = ci.invalidateAppearanceInfo();
        end

        function ci = lineWidthByAxes(ci, axesSpec, varargin)
            p = inputParser();
            p.addOptional('widthFn', @(n) (1:n)', ...
                @(x) isvector(x) || isa(x, 'function_handle'));
            p.parse(varargin{:});

            ci.warnIfNoArgOut(nargout);
            ci.axisLookupByAttributes(axesSpec);

            ci.appearanceLineWidthByAttributesList = [];
            ci.appearanceLineWidthByAttributesMap = [];

            % want list to be cell of cellstr
            if ~iscell(axesSpec), axesSpec = {axesSpec}; end
            if iscellstr(axesSpec), axesSpec = {axesSpec}; end
            ci.appearanceLineWidthByAxesList = axesSpec;
            ci.appearanceLineWidthByAxesMap = p.Results.widthFn;
            ci = ci.invalidateAppearanceInfo();
        end

        function appear = applyAppearanceModifications(ci, appear)

            % Color
            if ~isempty(ci.appearanceColorByAttributesList)
                % Color by attributes
                list = ci.appearanceColorByAttributesList;

                % remove attributes not in use along an axis
                list = setdiff(list, ci.attributeNames(isnan(ci.attributeAlongWhichAxis)));
                if isempty(list), return, end

                % generate combinatorial list of attribute values
                valueList = cell(numel(list), 1);
                for i = 1:numel(list)
                    vals = ci.getAttributeValueList(list{i});
                    if ~iscell(vals), vals = num2cell(vals); end
                    valueList{i} = struct(list{i}, vals);
                end
                combined = TensorUtils.buildCombinatorialStructTensor(valueList{:});
                nVals = numel(combined);

                cmap = ci.appearanceColorByAttributesCmap;
                if isa(cmap, 'function_handle')
                    cmap = cmap(nVals);
                end

                % match appearances to attribute value sets
                for c = 1:numel(appear)
                    cond = ci.conditions(c);
                    for v = 1:numel(combined)
                        if isequal(rmfield(cond, setdiff(fieldnames(cond), list)), combined(v))
                            if iscell(cmap)
                                appear(c).Color = cmap{v};
                            else
                                appear(c).Color = cmap(v, :);
                            end
                        end
                    end
                end

            elseif ~isempty(ci.appearanceColorByAxesList)
                % color by axes
                list = ci.appearanceColorByAxesList;

                allAttr = [list{:}];

                % generate combinatorial list of axis value values
                valueList = cell(numel(list), 1);
                for i = 1:numel(list)
                    valueList{i} = ci.getAxisValueList(list{i});
                end
                combined = TensorUtils.buildCombinatorialStructTensor(valueList{:});
                nVals = numel(combined);

                cmap = ci.appearanceColorByAxesCmap;
                if isa(cmap, 'function_handle')
                    cmap = cmap(nVals);
                elseif isstring(cmap)
                    cmap = cellstr(cmap);
                end

                % match appearances to attribute value sets
                for c = 1:numel(appear)
                    cond = ci.conditions(c);
                    for v = 1:numel(combined)
                        if isequal(rmfield(cond, setdiff(fieldnames(cond), allAttr)), combined(v))
                            if iscell(cmap)
                                appear(c).Color = cmap{v};
                            else
                                appear(c).Color = cmap(v, :);
                            end
                        end
                    end
                end
            end

            % Line Style
            if ~isempty(ci.appearanceLineStyleByAttributesList)
                % Color by attributes
                list = ci.appearanceLineStyleByAttributesList;

                % remove attributes not in use along an axis
                list = setdiff(list, ci.attributeNames(isnan(ci.attributeAlongWhichAxis)));
                if isempty(list), return, end

                % generate combinatorial list of attribute values
                valueList = cell(numel(list), 1);
                for i = 1:numel(list)
                    vals = ci.getAttributeValueList(list{i});
                    if ~iscell(vals), vals = num2cell(vals); end
                    valueList{i} = struct(list{i}, vals);
                end
                combined = TensorUtils.buildCombinatorialStructTensor(valueList{:});
                nVals = numel(combined);

                map = ci.appearanceLineStyleByAttributesMap;
                if isa(map, 'function_handle')
                    map = map(nVals);
                end

                % match appearances to attribute value sets
                for c = 1:numel(appear)
                    cond = ci.conditions(c);
                    for v = 1:numel(combined)
                        if isequal(rmfield(cond, setdiff(fieldnames(cond), list)), combined(v))
                            appear(c).LineStyle = map{v};
                        end
                    end
                end

            elseif ~isempty(ci.appearanceLineStyleByAxesList)
                % color by axes
                list = ci.appearanceLineStyleByAxesList;

                allAttr = [list{:}];

                % generate combinatorial list of axis value values
                valueList = cell(numel(list), 1);
                for i = 1:numel(list)
                    valueList{i} = ci.getAxisValueList(list{i});
                end
                combined = TensorUtils.buildCombinatorialStructTensor(valueList{:});
                nVals = numel(combined);

                map = ci.appearanceLineStyleByAxesMap;
                if isa(map, 'function_handle')
                    map = map(nVals);
                end

                % match appearances to attribute value sets
                for c = 1:numel(appear)
                    cond = ci.conditions(c);
                    for v = 1:numel(combined)
                        if isequal(rmfield(cond, setdiff(fieldnames(cond), allAttr)), combined(v))
                            appear(c).LineStyle = map{v};
                        end
                    end
                end
            end

            % Line Width
            if ~isempty(ci.appearanceLineWidthByAttributesList)
                % Color by attributes
                list = ci.appearanceLineWidthByAttributesList;

                % remove attributes not in use along an axis
                list = setdiff(list, ci.attributeNames(isnan(ci.attributeAlongWhichAxis)));
                if isempty(list), return, end

                % generate combinatorial list of attribute values
                valueList = cell(numel(list), 1);
                for i = 1:numel(list)
                    vals = ci.getAttributeValueList(list{i});
                    if ~iscell(vals), vals = num2cell(vals); end
                    valueList{i} = struct(list{i}, vals);
                end
                combined = TensorUtils.buildCombinatorialStructTensor(valueList{:});
                nVals = numel(combined);

                map = ci.appearanceLineWidthByAttributesMap;
                if isa(map, 'function_handle')
                    map = map(nVals);
                end

                % match appearances to attribute value sets
                for c = 1:numel(appear)
                    cond = ci.conditions(c);
                    for v = 1:numel(combined)
                        if isequal(rmfield(cond, setdiff(fieldnames(cond), list)), combined(v))
                            appear(c).LineWidth = map(v);
                        end
                    end
                end

            elseif ~isempty(ci.appearanceLineWidthByAxesList)
                % color by axes
                list = ci.appearanceLineWidthByAxesList;

                allAttr = [list{:}];

                % generate combinatorial list of axis value values
                valueList = cell(numel(list), 1);
                for i = 1:numel(list)
                    valueList{i} = ci.getAxisValueList(list{i});
                end
                combined = TensorUtils.buildCombinatorialStructTensor(valueList{:});
                nVals = numel(combined);

                map = ci.appearanceLineWidthByAxesCmap;
                if isa(map, 'function_handle')
                    map = map(nVals);
                end

                % match appearances to attribute value sets
                for c = 1:numel(appear)
                    cond = ci.conditions(c);
                    for v = 1:numel(combined)
                        if isequal(rmfield(cond, setdiff(fieldnames(cond), allAttr)), combined(v))
                            appear(c).LineWidth = map(v);
                        end
                    end
                end
            end
        end
    end

    methods % Attribute related
        function [tf, idx] = hasAttribute(ci, name)
            if isnumeric(name)
                [tf, idx] = ismember(name, 1:ci.nAttributes);
            else
                [tf, idx] = ismember(name, ci.attributeNames);
            end
        end

        function idx = assertHasAttribute(ci, name)
            [tf, idx] = ci.hasAttribute(name);
            if ~all(tf)
                if isnumeric(name)
                    name = TrialDataUtilities.String.strjoin(name(~tf), ', ');
                elseif iscell(name)
                    name = TrialDataUtilities.String.strjoin(name(~tf));
                end
                error('Attribute(s) %s not found', name);
            end
        end

        function na = get.nAttributes(ci)
            na = length(ci.attributeNames);
        end

        function idxList = getAttributeIdx(ci,name)
            if isempty(name)
                idxList = [];
                return;
            end

            if isnumeric(name)
                % already idx, just return
                idxList = floor(name);
                idxList(idxList < 0 | idxList > ci.nAttributes) = NaN;
                return;
            end

            if ~iscell(name)
                name = {name};
            end

            idxList = nan(length(name), 1);
            for i = 1:length(name)
                if ischar(name{i})
                    idx = find(strcmp(ci.attributeNames, name{i}), 1);
                else
                    idx = name{i};
                end
                if isempty(idx)
                    error('Cannot find attribute named %s', name{i});
                end
                idxList(i) = idx;
            end
        end

        function tf = getIsAttributeNumeric(ci, name)
            idx = ci.getAttributeIdx(name);
            tf = ci.attributeNumeric(idx);
        end

        % return an A x 1 numeric array of constants in the AttributeValue*
        % set listed above, describing how this attribute's values are
        % determined
        function modes = get.attributeValueModes(ci)
            % check for manual value list, then manual bins, then auto
            % bins, otherwise auto value list
            modes = nanvec(ci.nAttributes);
            for i = 1:ci.nAttributes
                if ~isempty(ci.attributeValueListsManual{i})
                    modes(i) = ci.AttributeValueListManual;
                elseif ~isempty(ci.attributeValueBinsManual{i})
                    modes(i) = ci.AttributeValueBinsManual;
                elseif ~isnan(ci.attributeValueBinsAutoCount(i))
                    modes(i) = ci.attributeValueBinsAutoModes(i);
                else
                    modes(i) = ci.AttributeValueListAuto;
                end
            end
        end

        % determine the number of attributes, where possible, otherwise
        % leave as NaN. returns A x 1 numeric array
        function nv = get.nValuesByAttribute(ci)
            nv = nanvec(ci.nAttributes);
            for i = 1:ci.nAttributes
                nv(i) = numel(ci.attributeValueLists{i});
            end
        end

        function desc = get.attributeDescriptions(ci)
            desc = ci.generateAttributeDescriptions();
        end

        function names = get.attributeDisplayAs(ci)
            % when a manual name is specified in .attributeDisplayAsManual,
            % use it, otherwise convert attributeName to Attribute Name
            names = cellvec(ci.nAttributes);
            for i = 1:ci.nAttributes
                if isempty(ci.attributeDisplayAsManual{i})
                    names{i} = TrialDataUtilities.Data.camelCaseToTitleCaseSpaced(ci.attributeNames{i});
                else
                    names{i} = ci.attributeDisplayAsManual{i};
                end
            end
        end

        function desc = generateAttributeDescriptions(ci, useColor)
            if nargin < 2
                useColor = false;
            end
            desc = cellvec(ci.nAttributes);
            isFilter = ci.attributeActsAsFilter;
            modes = ci.attributeValueModes;
            displayList = ci.attributeDisplayAs;
            for i = 1:ci.nAttributes
                name = ci.attributeNames{i};
                displayAs = displayList{i};
                nValues = ci.nValuesByAttribute(i);
                nAutoBins = ci.attributeValueBinsAutoCount(i);

                switch modes(i)
                    case ci.AttributeValueListManual
                        suffix = sprintf('%d', nValues);
                    case ci.AttributeValueListAuto
                        suffix = sprintf('%d auto', nValues);
                    case ci.AttributeValueBinsManual
                        suffix = sprintf('%d bins', nValues);
                    case ci.AttributeValueBinsAutoUniform
                        suffix = sprintf('%d uniform-bins', nAutoBins);
                    case ci.AttributeValueBinsAutoQuantiles
                        suffix = sprintf('%d quantiles', nAutoBins);
                end

                if isFilter(i)
                    filterStr = ' filter';
                else
                    filterStr = '';
                end

                if ci.attributeNumeric(i)
                    numericStr = '#';
                else
                    numericStr = '@';
                end

                if isempty(ci.attributeUnits{i})
                    unitStr = '';
                else
                    unitStr = " in " + ci.attributeUnits(i);
                end
                if ~useColor
                    desc{i} = sprintf('%s as %s (%s%s%s)%s', name, displayAs, numericStr, suffix, filterStr, unitStr);
                else
                    desc{i} = sprintf('{purple}%s {darkGray}(%s%s{bright red}%s{darkGray})%s', name, numericStr, suffix, filterStr, unitStr);
                end
            end
        end

        % add a new attribute
        function ci = addAttribute(ci, name, varargin)
            ci.warnIfNoArgOut(nargout);

            p = inputParser;
            p.addRequired('name', @isstringlike);
            p.addParameter('units', '', @isstringlike);
            % is this attribute always numeric?
            % list of allowed values for this value (other values will be ignored)
            p.addParameter('displayAs', '', @isstringlike);
            p.addParameter('valueList', {}, @(x) islogical(x) || isnumeric(x) || iscell(x) || isstring(x));
            p.addParameter('valueListDisplayAs', {}, @(x) isempty(x) || iscellstr(x));
            p.addParameter('valueBins', {}, @(x) isnumeric(x) || iscell(x));
            p.addParameter('numeric', false, @islogical);
            p.addParameter('asVector', false, @islogical);
            p.parse(name, varargin{:});
            valueList = p.Results.valueList;
            if isstring(valueList)
                valueList = cellstr(valueList);
            end

            [tf, iAttr] = ci.hasAttribute(name);
            if tf
%                 warning('ConditionDescriptor already has attribute %s', name);
            else
                iAttr = ci.nAttributes + 1;
            end
            ci.attributeNames{iAttr} = name;
            ci.attributeUnits{iAttr} = p.Results.units;
            if isempty(valueList)
                ci.attributeNumeric(iAttr) = p.Results.numeric;
            else
                ci.attributeNumeric(iAttr) = isnumeric(valueList) || islogical(valueList);
            end
            ci.attributeAsVector(iAttr) = p.Results.asVector;
            ci.attributeDisplayAsManual{iAttr} = p.Results.displayAs;

            if isempty(valueList)
                ci.attributeValueListsManual{iAttr} = {};
                assert(isempty(p.Results.valueListDisplayAs), 'valueListDisplayAs may only be specified when valueList is also specified');
                ci.attributeValueListsAsStringsManual{iAttr} = {};
            else
                %assert(isnumeric(valueList) || iscell(valueList), 'ValueList must be numeric or cell');
                % filter for unique values or
                if ~isempty(p.Results.valueListDisplayAs)
                    as = p.Results.valueListDisplayAs;
                    assert(iscellstr(as) && numel(as) == numel(valueList), 'valueListDisplayAs must have same size as value list');
                else
                    as = {};
                end
                [valueList, iA] = unique(valueList, 'stable');
                ci.attributeValueListsManual{iAttr} = valueList;

                if ~isempty(as)
                    as = as(iA);
                    ci.attributeValueListsAsStringsManual{iAttr} = as;
                else
                    ci.attributeValueListsAsStringsManual{iAttr} = [];
                end

            %    if ~iscell(valueList)
             %       valueList = num2cell(valueList);
             %   end
            end

            ci.attributeValueBinsManual{iAttr} = [];
            ci.attributeValueBinsAutoCount(iAttr) = NaN;
            ci.attributeValueBinsAutoModes(iAttr) = NaN;
            ci = ci.notifyConditionsChanged();
        end

        function ci = addAttributes(ci, names)
            ci.warnIfNoArgOut(nargout);
            for i = 1:numel(names)
                ci = ci.addAttribute(names{i});
            end
        end

        % remove an existing attribute
        function ci = removeAttribute(ci, varargin)
            ci.warnIfNoArgOut(nargout);

            if iscell(varargin{1})
                attributes = varargin{1};
            else
                attributes = varargin;
            end

            ci.warnIfNoArgOut(nargout);

            if ~isnumeric(attributes)
                % check all exist
                ci.getAttributeIdx(attributes);
            else
                attributes = ci.attributeNames(attributes);
            end

            if ~ci.hasAttribute(attributes)
                error('ConditionDescriptor has no attribute %s', name);
            end

            iAttr = ci.getAttributeIdx(attributes);
            maskOther = true(ci.nAttributes, 1);
            maskOther(iAttr) = false;

            ci = ci.maskAttributes(maskOther);
        end

        function ci = maskAttributes(ci, mask)
            ci.warnIfNoArgOut(nargout);

            idxRemove = find(~mask);
            if ~any(idxRemove)
                return;
            end

            % first remove the attributes from any axes they are on
            ci = ci.removeAttributesFromAxes(idxRemove);

            % then remove it from the attribute lists
            ci.attributeNames = ci.attributeNames(mask);
            ci.attributeUnits = ci.attributeUnits(mask);
            ci.attributeDisplayAsManual = ci.attributeDisplayAsManual(mask);
            ci.attributeNumeric = ci.attributeNumeric(mask);
            ci.attributeAsVector = ci.attributeAsVector(mask);
            ci.attributeValueListsManual = ci.attributeValueListsManual(mask);
            ci.attributeValueLists = ci.attributeValueLists(mask);
            ci.attributeValueListsAsStrings = ci.attributeValueListsAsStrings(mask);
            ci.attributeValueBinsAutoCount = ci.attributeValueBinsAutoCount(mask);
            ci.attributeValueBinsAutoModes = ci.attributeValueBinsAutoModes(mask);
            ci.attributeValueBinsManual = ci.attributeValueBinsManual(mask);
            ci.attributeValueListsAsStringsManual = ci.attributeValueListsAsStringsManual(mask);
        end

        % set all attribute value lists to auto
        function ci = setAllAttributeValueListsAuto(ci)
            ci.warnIfNoArgOut(nargout);
            for i = 1:ci.nAttributes
                ci = ci.setAttributeValueListAuto(i);
            end
        end

        % restore value list to automatically include all values, with no
        % binning
        function ci = setAttributeValueListAuto(ci, attr)
            ci.warnIfNoArgOut(nargout);
            iAttr = ci.assertHasAttribute(attr);
            ci.attributeValueListsManual{iAttr} = [];
            ci.attributeValueBinsManual{iAttr} = [];
            ci.attributeValueBinsAutoCount(iAttr) = NaN;
            ci.attributeValueBinsAutoModes(iAttr) = NaN;
            ci.attributeValueListsAsStringsManual{iAttr} = {};
            ci = ci.notifyConditionsChanged();
        end

        function ci = setAttributeUnits(ci, attr, units)
            ci.warnIfNoArgOut(nargout);
            iAttr = ci.assertHasAttribute(attr);
            ci.attributeUnits{iAttr} = units;
            ci = ci.invalidateNames();
        end

        function ci = setAttributeDisplayAs(ci, attr, displayAs)
            ci.warnIfNoArgOut(nargout);
            iAttr = ci.assertHasAttribute(attr);
            ci.attributeDisplayAsManual{iAttr} = displayAs;
            ci = ci.invalidateNames();
        end

        function ci = setAttributeNumeric(ci, attr, tf)
            ci.warnIfNoArgOut(nargout);
            iAttr = ci.assertHasAttribute(attr);

            ci.attributeNumeric(iAttr) = tf;
            ci = ci.notifyConditionsChanged();
        end

        function ci = setAttributeAsVector(ci, attr, tf)
            ci.warnIfNoArgOut(nargout);
            iAttr = ci.assertHasAttribute(attr);

            % check that attribute value lists are vectors not cells
            valueList = ci.getAttributeValueList(iAttr);
            if ~isempty(valueList)
                if tf
                    % making it into a vector
                    if iscellstr(valueList) %#ok<ISCLSTR>
                        valueList = string(valueList);
                    end
                    assert(~iscell(valueList) || (numel(valueList) == 1 && ismissing(valueList{1})) || ci.attributeValueListIsBinned(iAttr), 'Attribute %s has manual value list that is not numeric vector which is required for numeric attributes', attr);
                else
                    assert(iscell(valueList) || isstring(valueList) || iscategorical(valueList), 'Attribute %s has manual value list that is not cell which is required for as vector attributes', attr);
                end
            end

            ci.attributeAsVector(iAttr) = tf;
            ci = ci.notifyConditionsChanged();
        end

        % manually set the attribute value list
        function ci = setAttributeValueList(ci, name, valueList, varargin)
            p = inputParser;
            p.addParameter('displayAs', {}, @(x) isempty(x) || ischar(x) || iscellstr(x));
            p.parse(varargin{:});

            ci.warnIfNoArgOut(nargout);

            iAttr = ci.getAttributeIdx(name);
            if isempty(valueList)
                ci.attributeValueListsManual{iAttr} = {};
                ci.attributeValueListsAsStringsManual{iAttr} = {};
            else
                if ischar(valueList)
                    valueList = {valueList};
                end
                % TODO add string support
                if isstring(valueList)
                    valueList = cellstr(valueList);
                end
                ci.attributeValueListsManual{iAttr} = valueList;

                % set the attributeValueListDisplayAs
                displayAs = p.Results.displayAs;
                if ~isempty(displayAs)
                    if ischar(displayAs)
                        displayAs = {displayAs};
                    end
                    assert(iscellstr(displayAs));
                else
                    displayAs = {};
                end
                ci.attributeValueListsAsStringsManual{iAttr} = displayAs;
            end

            %ci.attributeNumeric(iAttr) = isnumeric(valueList) || islogical(valueList);
            ci = ci.notifyConditionsChanged();
        end

        function ci = setAttributeValueListDisplayAs(ci, name, displayAs)
            ci.warnIfNoArgOut(nargout);

            iAttr = ci.getAttributeIdx(name);
            switch(ci.attributeValueModes(iAttr))
                case {ci.AttributeValueListManual, ci.AttributeValueBinsManual}
                    if ~isempty(displayAs)
                        if ischar(displayAs)
                            displayAs = {displayAs};
                        end
                        assert(iscellstr(displayAs));
                    else
                        displayAs = {};
                    end
                    ci.attributeValueListsAsStringsManual{iAttr} = displayAs;
                otherwise
                    error('Attribute must have a fixed value list in order to specify the valueListDisplayAs manually');
            end

            ci = ci.notifyConditionsChanged();
        end

        function ci = fixAttributeValueList(ci, name)
            ci.warnIfNoArgOut(nargout);
            iAttr = ci.getAttributeIdx(name);
            for i = 1:numel(iAttr)
                idx = iAttr(i);
                ci = ci.setAttributeValueList(iidx,  ci.attributeValueLists{idx});
            end
        end

        function ci = fixAllAttributeValueLists(ci)
            ci.warnIfNoArgOut(nargout);
            for iA = 1:ci.nAxes
                ci = ci.fixAttributeValueList(iA);
            end
        end

        % manually set attribute bins
        function ci = binAttribute(ci, name, bins)
            ci.warnIfNoArgOut(nargout);

            if isvector(bins) && isnumeric(bins)
                assert(issorted(bins), 'Bins specified as vector must be in sorted order');
                binsMat = nan(numel(bins)-1, 2);
                binsMat(:, 1) = bins(1:end-1);
                binsMat(:, 2) = bins(2:end);
            elseif iscell(bins)
                binsMat = cell2mat(bins);
            else
                binsMat = bins;
            end

            assert(ismatrix(binsMat) && size(binsMat, 2) == 2, 'Bins matrix must be nBins x 2');
            assert(all(binsMat(:, 2) >= binsMat(:, 1)), 'Bins matrix must have larger value in second column than first');

            % convert nBins x 2 matrix to nBins x 1 cellvec
            binsCell = mat2cell(binsMat, ones(size(binsMat, 1), 1), 2);

            iAttr = ci.getAttributeIdx(name);
            ci.attributeValueBinsManual{iAttr} = binsCell;
            ci.attributeNumeric(iAttr) = true;
            ci.attributeAsVector(iAttr) = true;
            ci.attributeValueListsManual{iAttr} = {};
            ci.attributeValueBinsAutoCount(iAttr) = NaN;
            ci.attributeValueBinsAutoModes(iAttr) = NaN;
            ci.attributeValueListsAsStringsManual{iAttr} = {};
            ci = ci.notifyConditionsChanged();
        end

        % automatically set attribute binned uniformly by range
        function ci = binAttributeUniform(ci, name, nBins)
            ci.warnIfNoArgOut(nargout);

            iAttr = ci.getAttributeIdx(name);

            ci.attributeValueBinsManual{iAttr} = [];
            ci.attributeNumeric(iAttr) = true;
            ci.attributeAsVector(iAttr) = true;
            ci.attributeValueListsManual{iAttr} = {};
            ci.attributeValueBinsAutoCount(iAttr) = nBins;
            ci.attributeValueBinsAutoModes(iAttr) = ci.AttributeValueBinsAutoUniform;
            ci.attributeValueListsAsStringsManual{iAttr} = {};
            ci = ci.notifyConditionsChanged();
        end

        % automatically set attribute binned into quantiles
        function ci = binAttributeQuantiles(ci, name, nQuantiles)
            ci.warnIfNoArgOut(nargout);
            if nargin < 3
                nQuantiles = 5;
            end

            iAttr = ci.assertHasAttribute(name);
            ci.attributeValueBinsManual{iAttr} = [];
            ci.attributeNumeric(iAttr) = true;
            ci.attributeAsVector(iAttr) = true;
            ci.attributeValueListsManual{iAttr} = {};
            ci.attributeValueBinsAutoCount(iAttr) = nQuantiles;
            ci.attributeValueBinsAutoModes(iAttr) = ci.AttributeValueBinsAutoQuantiles;
            ci.attributeValueListsAsStringsManual{iAttr} = {};
            ci = ci.notifyConditionsChanged();
        end

        function list = get.attributeValueListsAsStringsManual(ci)
            if isempty(ci.attributeValueListsAsStringsManual)
                list = cellvec(ci.nAttributes);
            else
                list = ci.attributeValueListsAsStringsManual;
            end
        end

        function values = generateConditionsAsStrings(ci, varargin)
            % publically callable version of buildConditionsAsStrings in case build methods
            % end up having side effects
            p = inputParser();
            p.addParameter('separator', ' ', @ischar);
            p.addParameter('short', false, @islogical);
            p.addParameter('includeUnits', true, @islogical); % .attribute = units struct
            p.parse(varargin{:});

            separator = string(p.Results.separator);

            if ci.nAxes == 0
                values = {TrialDataUtilities.Data.structToString(ci.conditions)};
            else
                valueLists = ci.generateAxisValueListsAsStrings(p.Results);
                values = TensorUtils.mapFromAxisLists(@(varargin) TrialDataUtilities.String.strjoin(string(varargin), separator),...
                    valueLists, 'asCell', false);
            end
            values = string(values);
        end

        function ci = sortWithinConditionsBy(ci, sortByList)
            ci.warnIfNoArgOut(nargout);
            if ischar(sortByList)
                sortByList = {sortByList};
            end
            assert(iscellstr(sortByList), 'sortByList must be string or cellstr');

            % strip leading '-' to check has each attribute
            attrNames = cell(numel(sortByList), 1);
            for i = 1:numel(sortByList)
                if strncmp(sortByList{i}, '-', 1)
                    attrNames{i} = sortByList{i}(2:end);
                else
                    attrNames{i} = sortByList{i};
                end
            end
            ci.assertHasAttribute(attrNames);

            ci.attributeSortByList = makecol(sortByList(:));
        end

    end

    % get, set data stored inside odc
    methods
        % NOTE: all of these should copy odc before writing to ittd

        function v = get.conditions(ci)
            v = ci.odc.conditions;
            if isempty(v)
                ci.odc.conditions = ci.buildConditions();
                v = ci.odc.conditions;
            end
        end

        function ci = set.conditions(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.conditions = v;
        end

        function v = get.conditionsAsStrings(ci)
            v = ci.odc.conditionsAsStrings;
            if isempty(v)
                ci.odc.conditionsAsStrings = ci.buildConditionsAsStrings();
                v = ci.odc.conditionsAsStrings;
            end
        end

        function ci = set.conditionsAsStrings(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.conditionsAsStrings = v;
        end
%
%         function v = get.conditionsAsStringsWithFilters(ci)
%             v = ci.odc.conditionsAsStringsWithFilters;
%             if isempty(v)
%                 ci.odc.conditionsAsStringsWithFilters = ci.buildConditionsAsStringsWithFilters();
%                 v = ci.odc.conditionsAsStringsWithFilters;
%             end
%         end
%
%         function ci = set.conditionsAsStringsWithFilters(ci, v)
%             ci.odc = ci.odc.copy();
%             ci.odc.conditionsAsStringsWithFilters = v;
%         end

        function v = get.conditionsAxisAttributesOnly(ci)
            v = ci.odc.conditionsAxisAttributesOnly;
            if isempty(v)
                ci.odc.conditionsAxisAttributesOnly = ci.buildConditionsAxisAttributesOnly();
                v = ci.odc.conditionsAxisAttributesOnly;
            end
        end

        function ci = set.conditionsAxisAttributesOnly(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.conditionsAxisAttributesOnly = v;
        end

        function v = get.appearances(ci)
            v = ci.odc.appearances;
            if isempty(v)
                ci.odc.appearances = ci.buildAppearances();
                v = ci.odc.appearances;
            end
        end

        function ci = set.appearances(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.appearances = v;
        end

        function v = get.names(ci)
            v = ci.odc.names;
            if isempty(v)
                ci.odc.names = ci.buildNames();
                v = ci.odc.names;
            end
        end

        function ci = set.names(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.names = v;
        end

        function v = get.namesShort(ci)
            v = ci.odc.namesShort;
            if isempty(v)
                ci.odc.namesShort = ci.buildNamesShort();
                v = ci.odc.namesShort;
            end
        end

        function ci = set.namesShort(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.namesShort = v;
        end

        function v = get.namesMultiline(ci)
            v = ci.odc.namesMultiline;
            if isempty(v)
                ci.odc.namesMultiline = ci.buildNamesMultiline();
                v = ci.odc.namesMultiline;
            end
        end

        function v = get.namesMultilineShort(ci)
            v = ci.buildNamesMultilineShort();
        end

        function ci = set.namesMultiline(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.namesMultiline = v;
        end

        function v = get.attributeValueLists(ci)
            v = ci.odc.attributeValueLists;
            if isempty(v)
                ci.odc.attributeValueLists = ci.buildAttributeValueLists();
                v = ci.odc.attributeValueLists;
            end
        end

        function ci = set.attributeValueLists(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.attributeValueLists = v;
        end

        function v = get.attributeValueListsAsStrings(ci)
            v = ci.odc.attributeValueListsAsStrings;
            if isempty(v)
                ci.odc.attributeValueListsAsStrings = ci.buildAttributeValueListsAsStrings();
                v = ci.odc.attributeValueListsAsStrings;
            end
        end

        function ci = set.attributeValueListsAsStrings(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.attributeValueListsAsStrings = v;
        end

        function v = get.axisValueLists(ci)
            v = ci.odc.axisValueLists;
            if isempty(v)
                ci.odc.axisValueLists = ci.buildAxisValueLists();
                v = ci.odc.axisValueLists;
            end
        end

        function ci = set.axisValueLists(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.axisValueLists = v;
        end

        function v = get.axisValueListsAsStrings(ci)
            v = ci.odc.axisValueListsAsStrings;
            if isempty(v)
                ci.odc.axisValueListsAsStrings = ci.buildAxisValueListsAsStrings();
                v = ci.odc.axisValueListsAsStrings;
            end
        end

        function ci = set.axisValueListsAsStrings(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.axisValueListsAsStrings = v;
        end

        function v = get.axisValueListsAsStringsShort(ci)
            v = ci.odc.axisValueListsAsStringsShort;
            if isempty(v)
                ci.odc.axisValueListsAsStringsShort = ci.buildAxisValueListsAsStringsShort();
                v = ci.odc.axisValueListsAsStringsShort;
            end
        end

        function ci = set.axisValueListsAsStringsShort(ci, v)
            ci.odc = ci.odc.copy();
            ci.odc.axisValueListsAsStringsShort = v;
        end

        function v = get.axisValueListsAsStringsManual(ci)
            if isempty(ci.axisValueListsAsStringsManual)
                v = cell(ci.nAxes, 1);
                v(:) = {''};
            else
                v = ci.axisValueListsAsStringsManual;
            end
        end

        function v = get.axisValueListsAsStringsShortManual(ci)
            if isempty(ci.axisValueListsAsStringsShortManual)
                v = cell(ci.nAxes, 1);
                v(:) = {''};
            else
                v = ci.axisValueListsAsStringsShortManual;
            end
        end

    end

    % build data stored inside odc (used by getters above)
    methods
        function values = buildConditionsAxisAttributesOnly(ci)
            if ci.nAxes == 0
                values = struct();
            else
                valueLists = ci.axisValueLists;
                values = TensorUtils.mapFromAxisLists(@structMergeMultiple,...
                    valueLists, 'asCell', false);
                if isempty(values)
                    values = struct([]);
                end
            end
        end

        function values = buildConditions(ci)
            values = ci.conditionsAxisAttributesOnly;

            if isempty(values)
                return;
            end

            % and add "wildcard" match for all other attributes that act as
            % filter (i.e. have manual value list or bins specified)
            whichAxis = ci.attributeAlongWhichAxis;
            isFilter = ci.attributeActsAsFilter;
            valueLists = ci.attributeValueLists;
            for iA = 1:ci.nAttributes
                if isnan(whichAxis(iA)) && isFilter(iA)
                    valueList = valueLists{iA};

                    % flatten any subgroupings of values in the value list
                    if ci.attributeAsVector(iA) && iscell(valueList)
                        valueList = [valueList{:}];
                    elseif ~ci.attributeAsVector(iA) && ~ischar(valueList)
                        valueList = [valueList(:)];
                    end
                    % wrap in cell to avoid scalar expansion
                    values = assignIntoStructArray(values, ci.attributeNames{iA}, {valueList});
                end
            end
        end

        % build a wildcard search struct where each .attribute field is the
        % value list for that attribute
        function values = buildStructAllAttributeValueLists(ci)
            values = struct();
            for iA = 1:ci.nAttributes
                values = assignIntoStructArray(values, ci.attributeNames{iA}, ...
                    ci.attributeValueLists(iA));
            end
        end

        function values = buildStructNonAxisAttributeValueLists(ci)
            whichAxis = ci.attributeAlongWhichAxis;
            values = struct();
            for iA = 1:ci.nAttributes
                if isnan(whichAxis(iA))
                    values = assignIntoStructArray(values, ci.attributeNames{iA}, ...
                        ci.attributeValueLists(iA));
                end
            end
        end

        function values = buildConditionsAsStrings(ci, separator)
            if nargin < 2
                separator = ' ';
            end
            if ci.nAxes == 0
                values = {structToString(ci.conditions)};
            else
                valueLists = ci.axisValueListsAsStrings;
                values = TensorUtils.mapFromAxisLists(@(varargin) TrialDataUtilities.String.strjoin(varargin, separator),...
                    valueLists, 'asCell', true);
            end
        end

        function valueListByAxes = buildAxisValueLists(ci)
            valueListByAxes = cellvec(ci.nAxes);
            for iX = 1:ci.nAxes
                % build a cellstr of descriptions of the values along this axis

                % G x 1 cell of cells: each contains a struct specifying an attribute specification for each element along the axis
                if isempty(ci.axisValueListsManual{iX})
                    % build auto list of attributes
                    valueListByAxes{iX} = makecol(buildAutoValueListForAttributeSet(ci.axisAttributes{iX}));
                else
                    valueListByAxes{iX} = makecol(ci.axisValueListsManual{iX});
                end

                valueListByAxes{iX} = makecol(valueListByAxes{iX}(:));

                valueListByAxes{iX} = orderfields(valueListByAxes{iX}, ci.axisAttributes{iX});
            end

            function values = buildAutoValueListForAttributeSet(attributes)
                % build a struct array for a set of attributes that walks all possible combinations of the attribute values
                if isempty(attributes)
                    % for singleton axes, only one empty value
                    values = struct();
                    return;
                end

                if ischar(attributes)
                    attributes = {attributes};
                end
                attrIdx = ci.getAttributeIdx(attributes);
                valueLists = ci.attributeValueLists(attrIdx);

                % convert bin edges value lists to the cell vectors
                for i = 1:numel(attrIdx)
                    switch ci.attributeValueModes(attrIdx(i))
                        case {ci.AttributeValueBinsManual, ci.AttributeValueBinsAutoUniform, ...
                                ci.AttributeValueBinsAutoQuantiles}
                            % convert valueList from Nbins x 2 matrix to
                            % Nbins x 1 cellvector so that it gets mapped
                            % correctly
                            valueLists{i} = mat2cell(valueLists{i}, ones(size(valueLists{i}, 1), 1));
                    end
                end

                values = TensorUtils.mapFromAxisLists(@buildStruct, valueLists, ...
                    'asCell', false);

                function s = buildStruct(varargin)
                    for j = 1:numel(varargin)
                        s.(attributes{j}) = varargin{j};
                    end
                end

            end
        end

        function strCell = buildAxisValueListsAsStrings(ci)
            strCell = ci.generateAxisValueListsAsStrings('separator', ' ');
        end

        function strCell = buildAxisValueListsAsStringsShort(ci)
            strCell = ci.generateAxisValueListsAsStrings('separator', ' ', 'short', true);
        end

        function strCell = generateAxisValueListsAsStrings(ci, varargin)
            p = inputParser();
            p.addParameter('separator', ' ', @ischar);
            p.addParameter('short', false, @islogical);
            p.addParameter('includeUnits', ci.includeUnits, @islogical);
            p.addParameter('logicalNotPrefix', ci.logicalNotPrefix, @ischar);
            p.addParameter('useDisplayAs', true, @islogical);
            p.addParameter('useManualIfPresent', true, @islogical);
            p.parse(varargin{:});

            separator = p.Results.separator;
            shortNames = p.Results.short;

            strCell = cellvec(ci.nAxes);
            valueLists = ci.axisValueLists;
            valueListsRaw = valueLists; % we'll modify some of the values in value list below
            randStrCell = ci.axisRandomizeModesAsStrings;

            % build units lookup
            if ~p.Results.includeUnits
                unitsLookup = struct();
            else
                unitsLookup = struct();
                for iA = 1:ci.nAttributes
                    unitsLookup.(ci.attributeNames{iA}) = ci.attributeUnits{iA};
                end
            end

            % build display as lookup
            displayAsLookup = struct();
            displayAsList = ci.attributeDisplayAs;
            for iA = 1:ci.nAttributes
                displayAsLookup.(ci.attributeNames{iA}) = displayAsList{iA};
            end

            % describe the list of values selected for along each position on each axis
            for iX = 1:ci.nAxes

                % check for usable axisValueListAsStrings(Short)Manual
                if p.Results.useManualIfPresent
                    if p.Results.short && ~isempty(ci.axisValueListsAsStringsShortManual{iX})
                        if numel(ci.axisValueListsAsStringsShortManual{iX}) == numel(valueLists{iX})
                            strCell{iX} = ci.axisValueListsAsStringsShortManual{iX};
                            continue;
                        else
                            warning('Mismatch between axisValueListsAsStringsShortManual{%d} and num axis values', iX);
                        end
                    elseif ~p.Results.short && ~isempty(ci.axisValueListsAsStringsManual{iX})
                        if numel(ci.axisValueListsAsStringsManual{iX}) == numel(valueLists{iX})
                            strCell{iX} = ci.axisValueListsAsStringsManual{iX};
                            continue;
                        else
                            warning('Mismatch between axisValueListsAsStringsManual{%d} and num axis values', iX);
                        end
                    end
                end

                % loop over all attributes on this axis
                attr = ci.axisAttributes{iX};
                attrIdx = ci.getAttributeIdx(attr);

                % replace binned values with strings
                for iA = 1:numel(attrIdx)
                    switch ci.attributeValueModes(attrIdx(iA))
                        case {ci.AttributeValueBinsManual, ci.AttributeValueBinsAutoUniform, ...
                                ci.AttributeValueBinsAutoQuantiles}
                            % convert valueList from 1 x 2 vector to '#-#' string
                            for iV = 1:numel(valueLists{iX})
                                if ~iscellstr(valueLists{iX}(iV).(attr{iA})) && ~isstring(valueLists{iX}(iV).(attr{iA}))
                                    if all(TrialDataUtilities.Data.isintegertol(cell2mat(valueLists{iX}(iV).(attr{iA}))))
                                        valueLists{iX}(iV).(attr{iA}) = sprintf("%d-%d", round(cell2mat(valueLists{iX}(iV).(attr{iA}))));
                                    else
                                        valueLists{iX}(iV).(attr{iA}) = sprintf("%.3g-%.3g", cell2mat(valueLists{iX}(iV).(attr{iA})));
                                    end
                                end
                            end
                    end

                    % check whether a manual value list as strings is used
                    % for this attribute (per-value display as)
                    if p.Results.useDisplayAs && ...
                            ismember(ci.attributeValueModes(attrIdx(iA)), [ci.AttributeValueBinsManual, ci.AttributeValueListManual])
                        displayAs = ci.attributeValueListsAsStringsManual{attrIdx(iA)};
                        if ~isempty(displayAs)
                            valuesThisAttr = ci.attributeValueLists{attrIdx(iA)};
                            for iV = 1:numel(valueLists{iX})
                                val = valueListsRaw{iX}(iV).(attr{iA});
                                [tf, idx] = ismemberCell(val, valuesThisAttr);
                                assert(tf, 'Value not found in list of values for attribute %s', ci.attributeNames{iA});
                                % substitute in the display as value
                                valueLists{iX}(iV).(attr{iA}) = displayAs{idx};
                            end

                            % remove units from unitsLookup
                            unitsLookup = rmfield(unitsLookup, attr{iA});
                        end
                    end
                end

                % ensure field ordering matches
                valueLists{iX} = makecol(orderfields(valueLists{iX}, attr));
                strCell{iX} = arrayfun(@(v) TrialDataUtilities.Data.structToString(v, ...
                    separator, 'includeFieldNames', ~shortNames, 'fieldNameSubstitutions', displayAsLookup,  'suffixByField', unitsLookup, ...
                    'logicalNotPrefix', p.Results.logicalNotPrefix), ...
                    valueLists{iX}, ...
                   'UniformOutput', true);

                % append randomization indicator when axis is randomized
                if ci.axisRandomizeModes(iX) ~= ci.AxisOriginal && ~shortNames
                    if ci.axisRandomizeModes(iX) == ci.AxisResampledFromSpecified
                        % indicate which attribute
                        strCell{iX} = arrayfun(@(s, from) s + " resampled from " + TrialDataUtilities.Data.structToString(from), ...
                            strCell{iX}, ci.axisRandomizeResampleFromList{iX});
                    else
                        strCell{iX} = cellfun(@(s) s + " " + string(randStrCell{iX}), strCell{iX});
                    end
                end
            end
        end

        function names = buildNames(ci, varargin)
            p = inputParser();
            p.addParameter('short', false, @islogical);
            p.addParameter('multiline', false, @islogical);
            p.addParameter('includeUnits', true, @islogical);
            p.parse(varargin{:});

            % pass along values(i) and the subscripts of that condition in case useful
            if ci.nConditions > 0
                % first check manual fields
                if p.Results.short && ~isempty(ci.namesShortManual)
                    names = ci.namesShortManual;
                    if TensorUtils.compareSizeVectors(size(names), ci.conditionsSize), return, end
                end
                if ~isempty(ci.namesManual)
                    names = ci.namesManual;
                    if TensorUtils.compareSizeVectors(size(names), ci.conditionsSize), return, end
                end

                % then use condition name fn, which defaults to using the
                % axis value lists as strings
                fn = ci.nameFn;
                if isempty(fn)
                    fn = @ConditionDescriptor.defaultNameFn;
                end
                names = fn(ci, p.Results);
                if iscellstr(names) %#ok<ISCLSTR>
                    names = string(names);
                end
                assert(isstring(names) && TensorUtils.compareSizeVectors(size(names), ci.conditionsSize), ...
                    'nameFn must return cellstr with same size as .conditions');
            else
                names = strings(0, 1);
            end
        end

        function names = buildNamesShort(ci)
            names = ci.buildNames('multiline', false, 'short', true);
        end

        function names = buildNamesMultilineShort(ci)
            names = ci.buildNames('multiline', true, 'short', true);
        end

        function names = buildNamesMultiline(ci)
            names = ci.buildNames('multiline', true, 'short', false);
        end

        function appearances = buildAppearances(ci)
            if ci.nConditions > 0
                appearFn = ci.appearanceFn;

                appearances = ci.defaultAppearanceFn();
                if ~isempty(appearFn)
                    try
                        appearances = appearFn(ci, appearances);
                    catch exc
                        warning('Error calling conditionAppearance function. Test this function directly using testConditionAppearanceFn');
                        disp(exc);
                    end
                end

                appearances = ci.applyAppearanceModifications(appearances);
            else
                appearances = [];
            end
        end

        function appearances = testConditionAppearanceFn(ci)
            % same as build appearances but does not catch errors to allow
            % for debugging
            if ci.nConditions > 0
                appearFn = ci.appearanceFn;

                appearances = ci.defaultAppearanceFn();
                if ~isempty(appearFn)
                    appearances = appearFn(ci, appearances);
                end

                appearances = ci.applyAppearanceModifications(appearances);
            else
                appearances = [];
            end
        end

        function valueList = buildAttributeValueLists(ci)
            % just pull the manual lists (ConditionInfo will deal with this
            % when it has the TrialData it's being applied to)
            modes = ci.attributeValueModes;
            valueList = cellvec(ci.nAttributes);
            for i = 1:ci.nAttributes
                switch modes(i)
                    case ci.AttributeValueListManual
                        valueList{i} = ci.attributeValueListsManual{i};
                    case ci.AttributeValueBinsManual
                        valueList{i} = ci.attributeValueBinsManual{i};
                    case ci.AttributeValueBinsAutoUniform
                        % placeholder string to be replaced by actual bins
                        % matrix
                        valueList{i} = arrayfun(@(bin) sprintf('bin%d', bin), ...
                            1:ci.attributeValueBinsAutoCount(i), 'UniformOutput', false);
                    case ci.AttributeValueBinsAutoQuantiles
                        % the number of bins is known, so they can be specified here
                        valueList{i} = arrayfun(@(bin) sprintf('quantile%d', bin), ...
                            1:ci.attributeValueBinsAutoCount(i), 'UniformOutput', false);
                    otherwise
                        % place holder, must be determined when
                        % ConditionInfo applies it to data
                        if ci.attributeNumeric(i)
                            valueList{i} = NaN;
                        else
                            valueList{i} = {missing};
                        end
                end
                valueList{i} = makecol(valueList{i});
            end
        end

        function valueList = buildAttributeValueListsAsStrings(ci)
            modes = ci.attributeValueModes;
            valueList = ci.attributeValueLists;
            units = ci.attributeUnits;
            valueDisplay = ci.attributeValueListsAsStringsManual;
            for i = 1:ci.nAttributes
                if strlength(units{i}) == 0
                    unitStr = "";
                else
                    unitStr = sprintf(" %s", units{i});
                end
                switch modes(i)
                    case ci.AttributeValueListManual
                        if ~isempty(valueDisplay{i})
                            % use manual stirngs
                            displayAs = string(makecol(valueDisplay{i}));
                            assert(numel(valueList{i}) == numel(displayAs), 'attributeValueListsAsStringsManual for attribute %s has the wrong number of entries');

                            valueList{i} = displayAs;

                        elseif ci.attributeNumeric(i)
                            if iscell(valueList{i})
                                % could have multiple attribute values
                                % grouped together as one element
                                if TrialDataUtilities.Data.isintegertol(valueList{i})
                                    valueList{i} = cellfun(@(i) sprintf('%d%s', i, unitStr), round(valueList{i}), 'UniformOutput', false);
                                else
                                    valueList{i} = cellfun(@(i) sprintf('%.3g%s', i, unitStr), valueList{i}, 'UniformOutput', false);
                                end
                                valueList{i} = cellfun(@(vals) TrialDataUtilities.String.strjoin(vals, ','), valueList{i}, 'UniformOutput', false);
                            else
                                if TrialDataUtilities.Data.isintegertol(valueList{i})
                                    valueList{i} = arrayfun(@(i) sprintf('%d%s', i, unitStr), round(valueList{i}), 'UniformOutput', false);
                                else
                                    valueList{i} = arrayfun(@(i) sprintf('%.3g%s', i, unitStr), valueList{i}, 'UniformOutput', false);
                                end
                            end
                        elseif ci.attributeAsVector(i)
                            valueList{i} = arrayfun(@char, valueList{i}, 'UniformOutput', false);
                        else
                            % non-numeric, can leave as is unless...
                            if ~iscellstr(valueList{i})
                                % could have multiple attribute values
                                % grouped together as one element
                                valueList{i} = cellfun(@(vals) TrialDataUtilities.String.strjoin(vals, ','), valueList{i}, 'UniformOutput', false);
                            end
                        end

                    case {ci.AttributeValueBinsManual, ci.AttributeValueBinsAutoUniform, ci.AttributeValueBinsAutoQuantiles}
                        if ~iscellstr(valueList{i})
                            if ~iscell(valueList{i})
                                bins = valueList{i};
                            else
                                bins = cat(1, valueList{i}{:});
                            end
                            if all(TrialDataUtilities.Data.isintegertol(bins(:)))
                                valueList{i} = arrayfun(@(row) sprintf('%d-%d%s', round(bins(row, 1)), round(bins(row, 2)), unitStr), ...
                                1:size(bins, 1), 'UniformOutput', false);
                            else
                                valueList{i} = arrayfun(@(row) sprintf('%.3g-%.3g%s', bins(row, 1), bins(row, 2), unitStr), ...
                                    1:size(bins, 1), 'UniformOutput', false);
                            end
                        end

                    case ci.AttributeValueListAuto
                        % auto list leave empty, must be determined when
                        % ConditionInfo applies it to data
                        valueList{i} = {'(automatically determined)'};
                end
                valueList{i} = makecol(string(valueList{i}));
            end
        end

        function valueList = getAttributeValueList(ci, name)
            idx = ci.getAttributeIdx(name);
            valueList = makecol(ci.attributeValueLists{idx});
        end

        function mode = getAttributeValueListMode(ci, name)
            idx = ci.getAttributeIdx(name);
            mode = ci.attributeValueModes(idx);
        end

        function tf = getIsAttributeBinned(ci, name)
            mode = ci.getAttributeValueListMode(name);
            tf = ismember(mode, [ci.AttributeValueBinsManual, ...
                ci.AttributeValueBinsAutoUniform, ...
                ci.AttributeValueBinsAutoQuantiles]);
        end

        function valueIdx = getAttributeValueIdx(ci, attr, value)
            [tf, valueIdx] = ismember(value, ci.getAttributeValueLists(attr));
            assert(tf, 'Value not found in attribute %s valueList', attr);
        end

        function a = defaultAppearanceFn(ci, varargin)
            % returns a AppearSpec array specifying the default set of appearance properties
            % for the given group. indsGroup is a length(ci.groupByList) x 1 array
            % of the inds where this group is located in the high-d array, and dimsGroup
            % gives the full dimensions of the list of groups.
            %
            % We vary color along all axes simultaneously, using the linear
            % inds.
            %
            % Alternatively, if no arguments are passed, simply return a set of defaults

            nConditions = ci.nConditions; %#ok<*PROPLC>

            a = repmat(AppearanceSpec(), ci.conditionsSize);

            if nConditions == 1
                cmap = [0.2 0.2 0.2];
            else
                if nConditions > 37
                    cmap = jet(nConditions);
                else
                    cmap = cat(1, TrialDataUtilities.Color.cbrewer('qual', 'Set1'), ...
                        TrialDataUtilities.Color.cbrewer('qual', 'Paired'), ...
                        TrialDataUtilities.Color.cbrewer('qual', 'Accent'), ...
                        TrialDataUtilities.Color.cbrewer('qual', 'Dark2'));
                end
            end

            for iC = 1:nConditions
                a(iC).Color = cmap(iC, :);
            end
        end

        function addColoredLabels(ci, varargin)
            p = inputParser();
            p.addParameter('axh', gca, @ishandle);
            p.addParameter('short', true, @islogical);
            p.addParameter('fillAlpha', 0.5, @isscalar);
            p.KeepUnmatched = true;
            p.parse(varargin{:});
            axh = p.Results.axh;

            au = AutoAxis(axh);
            strCell = ci.buildNames('short', p.Results.short, 'multiline', false);
            cmap = ci.conditionColors;
            au.addColoredLabels(strCell, cmap, 'fillAlpha', p.Results.fillAlpha, p.Unmatched);
            au.update();
        end
    end

    methods(Static) % Default nameFn and appearanceFn
        function nameCell = defaultNameFn(ci, varargin)
            % receives the condition descriptor itself and returns a
            %  a cell tensor specifying the names of each condition
            p = inputParser();
            p.addParameter('multiline', false, @islogical);
            p.addParameter('short', false, @islogical);
            p.addParameter('includeUnits', true, @islogical);

            p.KeepUnmatched = true;
            p.parse(varargin{:});

            if p.Results.multiline
                separator = char(10); %#ok<CHARTEN>
            else
                separator = ' ';
            end
            nameCell = ci.generateConditionsAsStrings('separator',separator, ...
                'short', p.Results.short, 'includeUnits', p.Results.includeUnits);
        end
    end

    methods(Static) % construct from another condition descriptor, used primarily by ConditionInfo
        function cdNew = fromConditionDescriptor(cd, cdNew)
            cd.warnIfNoArgOut(nargout);

            if nargin < 2
                cdNew = ConditionDescriptor();
            end

            meta = ?ConditionDescriptor;
            props = meta.PropertyList;

            for iProp = 1:length(props)
                prop = props(iProp);
                if prop.Dependent || prop.Constant || prop.Transient
                    continue;
                else
                    name = prop.Name;
                    cdNew.(name) = cd.(name);
                end
            end

            cdNew.odc = ConditionDescriptorOnDemandCache();

            cdNew = cdNew.invalidateCache();
        end

        % construct condition descriptor from a struct of attribute values
        % for numeric attributes, if there are more than 10 different
        % values, the attribute will be binned into quintiles
        function cd = fromStruct(s)
            cd = ConditionDescriptor();
            cd = cd.addAttributes(fieldnames(s));
        end

        function cd = createManualWithSize(sz, varargin)
            p = inputParser();
            p.addParameter('axisNames', {}, @iscellstr);
            p.addParameter('valuesAlongAxes', {}, @iscell);
            p.parse(varargin{:});

            cd = ConditionDescriptor();

            nAxes = numel(sz);

            if isempty(p.Results.axisNames)
                if nAxes == 1
                    axisNames = {'condition'};
                else
                    axisNames = arrayfun(@(i) sprintf('a%d', i), (1:nAxes)', 'UniformOutput', false);
                end
            else
                axisNames = p.Results.axisNames;
            end
            if isempty(p.Results.valuesAlongAxes)
                valuesAlongAxes = cell(nAxes, 1);
                for iA = 1:nAxes
                    valuesAlongAxes{iA} = (1:sz(iA))';
                end
            else
                valuesAlongAxes = p.Results.valuesAlongAxes;
            end

            for iA = 1:nAxes
                cd = cd.addAttribute(axisNames{iA}, 'valueList', valuesAlongAxes{iA});
            end
            cd = cd.groupBy(axisNames{:});
            cd = cd.fixAllAxisValueLists();
        end

        function cd = concatenateAlongAxis(cdCell, axisName)
            if numel(cdCell) == 1
                cd = cdCell{1};
                return;
            end

            cd = cdCell{1};
            aIdx = cd.axisLookupByAttributes(axisName);

            % check for condition axis count match
            nAxes = cellfun(@(cd) cd.nAxes, cdCell);
            assert(numel(unique(nAxes)) == 1 || all(nAxes == 0 | nAxes == 1));

            % check for equal conditions size
            sz = cd.conditionsSize;
            sz(aIdx) = 1;
            N = numel(cdCell);
            for i = 2:N
                szThis = cdCell{i}.conditionsSize;
                szThis(aIdx) = 1;
                assert(TensorUtils.compareSizeVectors(sz, szThis), 'Condition Size for cdCell{%d} does not match cdCell{1}', i);
            end

            for i = 1:N
                if isa(cdCell{i}, 'ConditionInfo')
                    cdCell{i} = cdCell{i}.fixAllValueLists().getConditionDescriptor();
                end
                assert(cdCell{i}.allAxisValueListsManual, 'cdCell{%d}: ConditionDescriptor must have manual axis value lists. Use .setAxisValueList or .fixValueListsByApplyingToTrialData', i);
            end

            % take union over attribute values on concatenation axis
            attr = cd.axisAttributes{aIdx};
            attrIdx = cd.getAttributeIdx(attr);
            nAttr = numel(attr);
            attrValueLists = cell(N, 1);
            attrValueListsAsStrings = cell(N, 1);
            for iAttr = 1:nAttr
                for iN = 1:N
                    attrValueLists{iN} = cd.attributeValueLists{attrIdx(iAttr)};
                    attrValueListsAsStrings{iN} = cd.attributeValueListsAsStrings{attrIdx(iAttr)};
                end
                [attrValueListMerged, select] = unique(cat(1, attrValueLists{:}));
                attrValueListsAsStringsFull = cat(1, attrValueListsAsStrings{:});
                cd = cd.setAttributeValueList(attrIdx(iAttr), attrValueListMerged, 'displayAs', attrValueListsAsStringsFull(select));
            end

            % determine if axis is numeric
            emptyAxisValue = struct();
            for iN = 1:N
                if cdCell{iN}.nAxes > 0
                    vals = cdCell{iN}.axisValueLists{aIdx}(1);
                    fields = fieldnames(vals);
                    for iF = 1:numel(fields)
                        if ischar(vals.(fields{iF}))
                            emptyAxisValue.(fields{iF}) = '';
                        elseif isscalar(vals.(fields{iF}))
                            emptyAxisValue.(fields{iF}) = NaN;
                        else
                            emptyAxisValue.(fields{iF}) = [];
                        end
                    end
                    break;
                end
            end

            % and concatenate value lists along axis
            axisValueLists = cell(N, 1);
            axisValueListsAsStrings = cell(N, 1);
            axisValueListsAsStringsShort = cell(N, 1);
            for iN = 1:N
                if cdCell{iN}.nAxes == 0
                    axisValueLists{iN} = emptyAxisValue;
                    axisValueListsAsStrings{iN} = cdCell{iN}.names;
                    axisValueListsAsStringsShort{iN} = cdCell{iN}.namesShort;
                else
                    axisValueLists{iN} = cdCell{iN}.axisValueLists{aIdx};
                    axisValueListsAsStrings{iN} = cdCell{iN}.axisValueListsAsStrings{aIdx};
                    axisValueListsAsStringsShort{iN} = cdCell{iN}.axisValueListsAsStringsShort{aIdx};
                end
            end

            cd = cd.setAxisValueList(aIdx, cat(1, axisValueLists{:}), ...
                'asStrings', cat(1, axisValueListsAsStrings{:}), ...
                'asStringsShort', cat(1, axisValueListsAsStringsShort{:}));
        end
    end

    methods(Static) % expansion to match up multiple ConditionDescriptors
        function [cdNew, cdSubstantivelyModified] = expandToMatch(cdList, varargin)
            p = inputParser();
            p.addParameter('expandValueLists', true, @islogical);
            p.parse(varargin{:});

            % all axis value lists need to be manual
            nC = numel(cdList);
            for iC = 1:nC
                cdList{iC}.assertAllAxisValueListsManual();
            end

            %% first, generate the expanded axis attributes
            % we need to end up every attribute in every axis across the cdList in the
            % final expanded list of axes

            % start with the axes attributes on first cd
            axisAttr = cdList{1}.axisAttributes;

            for iC = 2:nC
                cdNew = cdList{iC};
                axisAttrNew = cdNew.axisAttributes;

                for iA = 1:cdNew.nAxes
                    thisAxisAttr = axisAttrNew{iA};

                    iAx = findAxesContainingAllAttr(axisAttr, thisAxisAttr);

                    if isempty(iAx)
                        % no axis contains ALL these attributes
                        % first check whether any axis contains ANY of these axis
                        iAx = findAxesContainingAnyAttr(axisAttr, thisAxisAttr);

                        if numel(iAx) == 0
                            % there is no axis contianing any of these other attributes
                            % so we just create a new axis at the end which will take all of these attributes
                            axisAttr{end+1, 1} = thisAxisAttr; %#ok<AGROW>

                        elseif numel(iAx) == 1
                            % this is exactly one axis that has some of these attributes, so we can just add the missing
                            % attributes to this axis. the axis value lists will later ensure that the conditions themselves do not change
                            axisAttr{iAx} = union(axisAttr{iAx}, thisAxisAttr, 'stable');

                        else
                            % these attributes are split over multiple existing axes, which is confusing and maybe
                            % impossible to deal with correctly, so we won't handle it for now
                            error('Attributes {%s} of axis %d of input %d are found partially on multiple axes in expanded ConditionDescriptor. This is not supported', ...
                                TrialDataUtilities.String.strjoin(thisAxisAttr, ','), iA, iC);
                        end
                    else
                        % there is an axis that containe all these attributes

                    end
                end
            end

            %% second, adapt each condition descriptor to the expanded axes

            % for each cd, we have to add additional axes to match the final axis list, but we
            % want to preserve the axis value lists. when an attribute is added to an existing axis
            % or to a new axis, we have to set its value list appropriately. if the attribute
            % is not filtered by this cd, it should be assigned a wildcard ( [] ) scalar value list.
            % if the attribute is filtered, by this cd, then the value list should be set to the
            % filtered value list.

            nAxes = numel(axisAttr);
            cdNew = cdList;
            attrAddedToAxes = cell(nC, nAxes); % list of attributes added to axes in each cd
            cdSubstantivelyModified = false(nC, 1);

            for iC = 1:numel(cdList)
                cd = cdList{iC};
                origAxisAttr = cd.axisAttributes;

                axisPositionNew = nanvec(numel(axisAttr));

                for iA = 1:numel(axisAttr) % loop over new axes
                    thisAxisAttr = axisAttr{iA};

                    % find an old axis that contains any of these axis attr
                    idxAxOrig = findAxesContainingAnyAttr(origAxisAttr, thisAxisAttr);

                    if isempty(idxAxOrig)
                        % add these as a new axis, set the value list to a scalar:
                        % either wildcard or set to the current attribute value list
                        [cdNew{iC}, axisPositionNew(iA)] = addNewAxis(cdNew{iC}, thisAxisAttr);
                        attrAddedToAxes{iC, iA} = thisAxisAttr;
                        cdSubstantivelyModified(iC) = true;

                    elseif numel(idxAxOrig) == 1
                        % axis either has some or all of the attributes
                        % add missing attributes to this axis with the appropriaite values
                        axisPositionNew(iA) = idxAxOrig;

                        % we call this even if all attr are present to ensure that the order of axisAttr
                        % is set to match across ceList{:}
                        [cdNew{iC}, attrAdded] = addMissingAttributesToAxis(cdNew{iC}, thisAxisAttr, idxAxOrig);
                        attrAddedToAxes{iC, iA} = attrAdded;
                        if ~isempty(attrAdded)
                            cdSubstantivelyModified(iC) = true;
                        end
                    end
                end

                % adjust the attribute orders to match
                cdNew{iC} = cdNew{iC}.permuteAxes(axisPositionNew);
            end

            if p.Results.expandValueLists
                %% third expand the value list sizes to match
                % do expansion via matched attributes:
                % we do our best to clone the value list in place. e.g. if cd{1} has an axis
                % {attrA x attrB} with (5 x 3 values) in it and cd{2} had an axis {attrA} with 5
                % values, then cdNew{2} will now have an axis {attrA, attrB} where attrB is a wildcard.
                % then we could clone the 5 values 3 times when we add the new value list.
                % but the 5 x 3 values could be in any order, and we might have only a subset of them.
                % so what we'll do is take the {attrA, attrB} value list, and for each value in that list
                % match it by only attrA into cd{2}'s {attrA} value list. If there's exactly one match,
                % we'll replicate it for all values of attrB. We'll first handle (a) and (b), and then
                % do this.
                %
                % here's a concrete example. suppose cd{1} has 1 axis with perturbDirection x perturbMagnitude with 8*3 values
                % and cd{2} has a perturbDirection axis with 8 values and perturbMagnitude filtered == None. Then we can expand this
                % in place to 8*3 where perturbMagnitude == None but matching perturbDirection.

                % loop over each axis
                for iA = 1:nAxes

                    attrThisAxis = axisAttr{iA};

                    valueListCell = cell(nC, 1);
                    for iC = 1:nC
                        valueListCell{iC} = cdNew{iC}.getAxisValueList(iA);
                    end
                    origValueListCell = valueListCell;

                    % build a table of which attributes were missing from each cd and were added
                    hasAttr_AttrByC = false(numel(attrThisAxis), nC);
                    for iAttr = 1:numel(attrThisAxis)
                        for iC = 1:nC
                            hasAttr_AttrByC(iAttr, iC) = ~ismember(attrThisAxis{iAttr}, attrAddedToAxes{iC, iA});
                        end
                    end

                    % do the matching expansion in place, typically preserving the left most valueList where possible
                    valueListCell = generateExpandedValueListsViaSharedMatch(valueListCell, attrThisAxis, hasAttr_AttrByC);

                    empty = cellfun(@isempty, valueListCell);
                    if any(empty)
                        error('No matching value for overlapping axis attribute values on axis %d', iA);
                    end

                    % update the value lists and check for modifications
                    for iC = 1:nC
                        cdNew{iC} = cdNew{iC}.setAxisValueList(iA, valueListCell{iC});
                        if ~isequal(valueListCell{iC}, origValueListCell{iC})
                            cdSubstantivelyModified(iC) = true;
                        end
                    end
                end
            end


            %%

            function idx = findAxesContainingAllAttr(axisAttr, thisAxisAttr)
                mask = false(numel(axisAttr), 1);
                for ia = 1:numel(axisAttr)
                    if all(ismember(thisAxisAttr, axisAttr{ia}))
                        mask(ia) = true;
                    end
                end

                idx = find(mask);
            end

            function idx = findAxesContainingAnyAttr(axisAttr, thisAxisAttr)
                mask = false(numel(axisAttr), 1);
                for ia = 1:numel(axisAttr)
                    if any(ismember(thisAxisAttr, axisAttr{ia}))
                        mask(ia) = true;
                    end
                end

                idx = find(mask);
            end

            function [cd, idxAxis] = addNewAxis(cd, axisAttr)
                % adds a new axis to cd and returns the index of this new axis
                % also set the new axis' value list to either wildcard if no attribute filter
                % exists, or to the value list if it is filtering

                value = struct();
                for ia = 1:numel(axisAttr)
                    attr = axisAttr{ia};

                    if cd.hasAttribute(attr)
                        attrValList = cd.getAttributeValueList(attr);
                        if iscell(attrValList) && numel(attrValList) == 1
                            attrValList = attrValList{1};
                        end
                        value.(attr) = attrValList;
                    else
                        cd = cd.addAttribute(attr);
                        value.(attr) = [];
                    end
                end

                cd = cd.addAxis(axisAttr, 'valueList', value);
                idxAxis = cd.nAxes;
            end

            function [cd, attrAdded] = addMissingAttributesToAxis(cd, axisAttr, idxAxOrig)
                % this axis has some (and possibly all) of the attributes in axisAttr
                % add the missing attributes. If missing,

                valueList = cd.getAxisValueList(idxAxOrig);

                missing = ~ismember(axisAttr, cd.axisAttributes{idxAxOrig});
                attrAdded = axisAttr(missing);

                if any(missing)
                    % axis does not have all of the attributes, value list should be amended
                    % to add the missing property
                    for ia = 1:numel(axisAttr)
                        if missing(ia)
                            attr = axisAttr{ia};
                            if cd.hasAttribute(attr)
                                attrValList = cd.getAttributeValueList(attr);
                                if iscell(attrValList) && numel(attrValList) == 1
                                    attrValList = attrValList{1};
                                end
                            else
                                cd = cd.addAttribute(attr);
                                attrValList = [];
                            end
                            [valueList(:).(axisAttr{ia})] = deal(attrValList);
                        end
                    end
                end

                cd = cd.replaceAxis(idxAxOrig, axisAttr, 'valueList', valueList);
            end

            function valueListCell = generateExpandedValueListsViaSharedMatch(valueListCell, attrList, hasAttr_AttrByC)

                C = numel(valueListCell);
                for iC1 = 1:C
                    for iC2 = iC1+1:C
                        valueList1 = valueListCell{iC1};
                        valueList2 = valueListCell{iC2};

                        newValueList1 = cell(0, 1);
                        newValueList2 = cell(0, 1);

                        maskShared = hasAttr_AttrByC(:, iC1) & hasAttr_AttrByC(:, iC2);
                        attrShared = attrList(maskShared);

                        tbl1Shared = struct2table(keepfields(valueList1, attrShared), 'AsArray', true);
                        tbl2Shared = struct2table(keepfields(valueList2, attrShared), 'AsArray', true);

                        % loop over valueList1, find shared-matches in valueList2
                        for iV1 = 1:numel(valueList1)
                            matchIn2Mask = ismember(tbl2Shared, tbl1Shared(iV1, :));

                            if any(matchIn2Mask)
                                newValueList1{iV1} = repmat(valueList1(iV1), nnz(matchIn2Mask), 1);
                                newValueList2{iV1} = valueList2(matchIn2Mask);
                            end
                        end

                        valueListCell{iC1} = cat(1, newValueList1{:});
                        valueListCell{iC2} = cat(1, newValueList2{:});
                    end
                end
            end

            function s = keepfields(s, fields)
                s = rmfield(s, setdiff(fieldnames(s), fields));
                s = orderfields(s, intersect(fields, fieldnames(s), 'stable'));
            end
        end
    end

    methods
        function cd = getConditionDescriptor(cd)
            % this does nothing here since it's already a condition
            % descriptor. This is used for "casting" back to ConditionDescriptor
            % from subclasses.
            cd.warnIfNoArgOut(nargout);
        end

        function cdManual = fixValueListsByApplyingToTrialData(cd, td)
            % converts automatic attribute and axis value lists to manual
            % lists, by building a ConditionInfo instance, applying to a
            % TrialData instance, fixing all value lists, and converting
            % back to a condition descriptor
            cd.warnIfNoArgOut(nargout);
            ci = ConditionInfo.fromConditionDescriptor(cd, td);
            cdManual = ci.getFixedConditionDescriptor();
        end
%
%         function cd = fixValueListsToCurrent(cd)
%             cd.warnIfNoArgOut(nargout);
%             assert(all(ismember(cd.attributeValueModes(idx), [ci.AttributeValueListManual, ci.AttributeValueBinsManual])), ...
%                 'All attributes must have manually specified value lists');
%             cd = cd.setAllAxisValueListsManualToCurrent();
%         end
    end

    methods(Access=protected) % Utility methods
        function warnIfNoArgOut(obj, nargOut)
            if nargOut == 0 && ~isa(obj, 'handle')
                warning('%s is not a handle class. If the instance handle returned by this method is not stored, this call has no effect.', ...
                    class(obj));
            end
        end

        function obj = copyIfHandle(obj)
            if isa(obj, 'handle')
                obj = obj.copy(); %#ok<MCNPN>
            end
        end
    end
end
